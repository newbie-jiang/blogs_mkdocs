# ARM黑话通识

更多的arm文档参考  https://github.com/ARM-software/abi-aa/releases



## arm指令集和Thumb指令集区别



ARM 指令集 vs Thumb（含 Thumb-2）指令集

**一句话概括**：

- **ARM(A32)**：固定 **32 位**指令编码，指令齐全、每条指令可带条件码，代码体积大。
- **Thumb(T16/T32)**：以 **16 位**为主（Thumb-1），在 **Thumb-2** 扩展到 **混合 16/32 位**，代码更紧凑，现代 M/R/A 内核基本都用 **Thumb-2** 作为默认/推荐模式。

------

### 关键差异

| 维度       | ARM(A32)                          | Thumb-1                                      | Thumb-2 (T32)                                         |
| ---------- | --------------------------------- | -------------------------------------------- | ----------------------------------------------------- |
| 指令长度   | 固定 32b                          | 固定 16b                                     | 混合 16/32b                                           |
| 代码密度   | 较低                              | 最高                                         | 高（接近 Thumb-1，且更强大）                          |
| 条件执行   | 每条指令有条件码                  | 无                                           | 通过 **IT** 指令成块条件执行（v8-M 对 IT 受限）       |
| 可用寄存器 | r0–r15 全面                       | 早期多数只便捷用 r0–r7（高寄存器需特殊指令） | 基本等同 ARM，用法接近 A32                            |
| 指令完备度 | 最全                              | 子集（缺少复杂寻址/乘累加/部分算术）         | 几乎补齐 ARM 的功能（含复杂寻址、长立即数等）         |
| 性能取向   | 取决于内核/总线，取指带宽充足时强 | 取指轻，功能受限                             | **综合最佳**：密度+功能+流水线友好                    |
| 适用内核   | 传统 A/R（v7 时代常见）           | 早期 M 内核                                  | **Cortex-M 全系仅支持 Thumb/Thumb-2**；R/A 也广泛支持 |

> 对 **Cortex-M（含 M7）**：**没有 ARM(A32) 状态**，只能运行 **Thumb-2（T32）** 指令集。

------

### 为什么 Thumb-2 成为主流

- **更小的代码＝更高的 I-Cache 命中＋更少的总线取指**：在嵌入式 SoC（Flash XIP、窄指令总线）上直接转化为性能与能效。
- **功能几乎不打折**：Thumb-2 通过 32 位“宽指令”补齐复杂寻址、长立即数、乘累加、饱和运算等。
- **可观测与实时**：更高密度让关键路径更容易“装进” ITCM/I-Cache，减少抖动。

------

### 条件执行与 IT

- **ARM(A32)**：每条指令都有条件码（如 `ADDEQ`、`SUBNE`），无需分支就能“选择性执行”。
- **Thumb-2**：用 **`IT` (If-Then)** 封装 1–4 条后续指令的条件执行，减少分支；但在 **ARMv8-M** 上对复杂 IT 块有限制，编译器也会减少使用以利于预测。

------

### 状态切换与互操作

- 早期 A/R 内核可在 **ARM 与 Thumb** 间切换（`BX`/`BLX`），函数指针最低位 **bit0 = 1 表示 Thumb**。
- **Cortex-M** 只有 Thumb 状态，无需/不能切换到 ARM。

------

### 编译器与选项

- **Cortex-M7**：

  ```
  -mcpu=cortex-m7 -mthumb -mfpu=fpv5-sp-d16|fpv5-d16 -mfloat-abi=hard
  ```

  - `-mthumb`：必须；M 只支持 Thumb。
  - FPU 选项按是否双精度选择 `fpv5-d16`（双精）或 `fpv5-sp-d16`（单精）。

- **A/R 内核**：可用 `-marm`（A32）或 `-mthumb`（T32）；现代多数情况下 **-mthumb（Thumb-2）更优**，除非极少数对 A32 有特定优化需求的场景。



## AAPCS

**Procedure Call Standard for the Arm Architecture (ARM架构的程序调用标准)**

参考 https://github.com/ARM-software/abi-aa/blob/c51addc3dc03e73a016a1e4edf25440bcac76431/aapcs32/aapcs32.rst#abstract



### 是什么 & 作用

- **函数调用与二进制接口标准**：规定参数/返回值如何传递、哪些寄存器需要保存、栈如何对齐、数据类型跨边界如何布局。
- 目标：**不同编译器/库/目标文件可互相链接与运行**（ABI 兼容）。

### 适用范围

- 用的 **Cortex-M7（Armv7-M, Thumb-2/T32）** 就遵循 **AAPCS32**。
- 浮点传参有三种变体：**soft / softfp / hard**（见下）。

### 调用约定（核心规则）

- **参数传递（整数/指针/标量）**：前 4 个用 `r0–r3`，其余进栈；64 位标量占用成对寄存器（如 `r0:r1`）。
- **返回值**：32 位用 `r0`；64 位用 `r0:r1`；大结构体通过 **隐藏返回指针**（caller 把缓冲区地址放 `r0`）。
- **寄存器保存义务**：
  - **callee-saved**：`r4–r11`（以及硬浮点时的 `d8–d15` / `s16–s31`）
  - **caller-saved**：`r0–r3`, `r12`, `lr`（如不另行保存），以及硬浮点时的 `d0–d7` / `s0–s15`
  - `sp` 必须始终有效并由被调函数恢复。
- **栈**：向下增长，**在任何公共接口处 `SP` 必须 8 字节对齐**（影响变参函数与一些指令的对齐要求）。

### 浮点变体（务必全工程一致）

- **hard**：浮点参数优先走 **VFP 寄存器**（`s/d`），返回也在 `s0/d0`；`d8–d15` 需 callee 保存。
- **softfp**：调用约定按整数寄存器/栈传参，但**允许**用硬件 FPU 计算（与 soft 二进制兼容）。
- **soft**：完全按整数寄存器/栈传参与计算（无硬件 FPU 依赖）。

> 编译/链接时必须让所有目标文件与库的 **float-ABI 变体一致**，否则链接或运行会出错。

### 数据与布局（跨函数/库的一致性）

- 基本类型大小与对齐、`struct/union/bit-field` 的布局方式由 AAPCS 及其 **Base Standard** 统一规定。
- **HFA/HVA**（同类浮点向量/聚合）在 **hard** 变体下可按 VFP 规则用浮点寄存器传递。

### 变参函数

- 为保证可遍历所有实参，**变参函数视作不使用浮点寄存器传参**（即便是 hard 变体），相关参数走核心寄存器/栈，依赖 8 字节栈对齐。

### 与 Thumb-2/函数指针

- AArch32 下函数指针**最低位为 1 表示 Thumb**；Cortex-M 只有 Thumb 状态（不涉及 ARM/A32 切换）。

### 写汇编时的最小守则

- 进入函数先**保存需要的 callee-saved 寄存器**，确保 **`SP` 8 字节对齐**；退出前对称恢复。
- 按所选 **float-ABI** 变体保存/恢复相应的 VFP 寄存器集合（若硬浮点且使用到）。



## 饱和算术 (saturating arithmetic)

**饱和算术**：当运算结果超出数据类型可表示范围时，不按  2^N 回绕，而是被**钳制**到上下界（最大/最小值；部分指令同时置饱和标志 Q）。

- **普通整数溢出**（按 2^N 取模）会“绕回去”。
   比如 8 位有符号：`120 + 120 = 240`，按 8 位二补码会变成 **-16**（溢出 wrap-around）。
- **饱和算术**不会绕回：结果被**夹紧到可表示范围的上下界**。
   同例在 8 位有符号范围 [-128, 127] 内：`120 + 120` 被**夹到 127**；
   8 位无符号范围 [0, 255] 内：`250 + 30` 被**夹到 255**。

某些 ARM 指令是“带饱和”的；手册用 `SignedSat(Q)` / `UnsignedSat(Q)` 这类**伪代码函数**来精确定义“**先算** → **再按 N 位上下界夹紧**（并可报告是否饱和）”的行为。实际硬件上，发生饱和还会通过 **Q 标志**反映出来。

### 使用场景

- **音频DSP**：16-bit/24-bit PCM 的混音、滤波累加、动态增益等——防止溢出回绕成巨大失真（剪裁而非回绕）。
   例：`y = __SSAT(acc, 16); // 紧到[-32768,32767]`
- **图像/视频像素运算**：卷积、亮度/对比度、Alpha 混合、SAD/SSE 累加；对每个字节/半字做并行饱和（`QADD8/QADD16`）。
   例：并行四像素加法不溢出到 <0 或 >255。
- **控制系统（PID 等）**：
  - **积分抗饱和**：积分项/控制输出限幅，避免风up 与执行器饱和后振荡。
  - **执行器命令限幅**：PWM、阀门、力矩指令被限制在安全区间。
- **定点（Q15/Q31）算法**：FIR/IIR、CORDIC、FFT 的乘加累加要饱和，保证数域稳定（M7 的“Q 指令族”就是为此准备的）。
- **通信与解码**：Viterbi/Turbo/LDPC 的路径度量或 LLR 需饱和，避免极端值主导，提升数值稳定性；AGC/相关器累加同理。
- **量化神经网络（INT8/UINT8）**：卷积/激活后把中间结果钳回量化区间（如 -128..127 或 0..255），避免溢出污染后续层。
- **安全/可靠场景**：
  - **饱和计数器**（错误计数、速率限制）不回绕；
  - **物理安全边界**（例如给电机/泵的最大/最小剂量/速度）永不越界。
- **图形/游戏数值**：位置/速度/颜色分量等限幅，防止坐标/颜色环回。
- **并行SIMD微优化**：用 `QADD8/QSUB8/QASX/QSAX` 等对 4×8bit 或 2×16bit 数据做饱和矢量运算，既快又安全。

小提示：

- 发生饱和会置位 **APSR.Q**（“累计饱和”）。需要监控时读后记得清零；CMSIS 有 `__SSAT(x,n)`、`__USAT(x,n)`、`__QADD/ __QSUB` 等可直接用。
- **不适用的典型场景**：需严格模 2N2^N2N 的算法（如多数密码学/CRC）应继续用“回绕”而**不是**饱和。



## 特权执行

**Armv7-M 的“特权执行（privileged execution）”模型**——也就是代码以哪种权限、在哪种模式下运行，以及应用如何向系统申请特权服务。

### 核心概念（一句话版）

- **Thread mode**：应用正常运行的模式；**复位后进入**。它可以是**特权**或**非特权**。
- **Handler mode**：所有**异常/中断**运行的模式；**总是特权**。
- **SVC（Supervisor Call）**：非特权应用在 Thread 模式下，通过执行 `SVC` 触发 **SVCall 异常**，转到 Handler 模式由内核以特权身份代办系统服务。

### 这对系统/应用各自意味着什么

- **系统（OS/内核/驱动）\**运行在\**特权**下：能访问系统控制空间（SCB/NVIC/SysTick/MPU 等）、配置内存与外设、管理任务和栈。
- **应用**通常运行在**非特权**下：
  - OS 可以把资源分配为**私有或共享**，并用 **MPU** 做访问隔离。
  - 非特权应用**不能**直接改系统控制寄存器或越权访问受保护区域；需要时用 **SVC** 向内核请求。
- **即使在特权 Thread 模式**，也可以选择用 **SVC** 走统一的系统调用路径，便于集中管理与审计。

### 在 Cortex-M 上会见到的落地

- 复位后进入 **Thread mode（默认特权，使用 MSP）**；OS 往往把普通任务切到**非特权 + PSP**。
- 非特权任务要做系统事：执行 `SVC` → 进入 **SVCall Handler（Handler 模式，特权）** → 内核完成操作 → 异常返回到原任务。
- 通过 **CONTROL.nPRIV** 位在 Thread 模式下区分特权/非特权；所有异常始终特权。

### 为什么要这样设计

- **安全与健壮性**：坏应用被隔离，不至于破坏内核或其它任务。
- **资源可控**：OS 统一分配/回收资源，并通过 SVC 提供规范的系统接口。

总结：**特权执行**是 Armv7-M 把“应用运行（Thread）”与“系统服务（Handler）”隔离的机制；应用一般非特权运行，遇到需要系统能力的场景，通过 **SVC→SVCall** 以特权方式由内核代办，从而实现资源隔离与系统安全。





