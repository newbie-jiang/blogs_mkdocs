# ARMv7-M架构手册个人解读



## ARMv7-M 仅支持thumb指令



![image-20250927234631649](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250927234631649.png)



## 程序员模型与特权

### 范畴与定位

**两层程序员模型**：

- **应用层程序员模型**（本章 A2）：应用开发所需的寄存器/指令/异常返回等最小知识。
- **系统层程序员模型**（B1 章）：为操作系统与系统服务准备的完整体系（异常控制、内存保护、调试、系统控制寄存器等）。

### 特权模型

- **特权（privileged）/非特权（unprivileged）** 两种权限级别。
- **系统代码**决定应用以何种权限运行；**操作系统**同时支持两种模式，**应用通常运行为非特权**。
- 运行为**非特权**的意义：
  - 允许 OS 把系统资源分配给应用（私有或共享）。
  - 提供进程/任务间隔离，保护 OS 不被故障应用拖垮。

### 运行模式与复位

- **Thread mode**：应用执行的基本模式；**复位后进入 Thread mode**。
- Thread mode 可为 **特权或非特权**（应用常见为非特权）。
- **Handler mode**：异常处理模式；**所有异常都在 Handler mode 执行**。

### 应用与系统的交互（系统调用）

- **SVC 机制**：Thread mode 可执行 **`SVC` 指令**触发 **SVCall 异常**；处理在 **Handler mode** 由 SVC 处理例程完成。
- **SVCall 的职责**：代表应用管理系统资源（如：外设访问、内存分配、软件栈管理等）。
- **替代路径**：若 Thread mode 本身是特权态，亦可**直接进行系统访问与控制**（无需 SVC）。

一句话流程图

- 复位 → **Thread mode**（应用）
   →（需要系统服务？）**SVC** → **SVCall @ Handler mode**（内核代办）→ 返回 **Thread mode** 继续执行。

区分应用/系统两层模型；引入特权/非特权与其安全意义；明确 Thread/Handler 两种运行模式与**“SVC=受控进入内核”**的交互方式；

![image-20250927234545693](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250927234545693.png)

## 数据类型和算数运算

### 内存中的数据类型（Memory）

- **Byte**：8 位
- **Halfword**：16 位
- **Word**：32 位
- 这只是**存储宽度**；CPU 取到寄存器里时，会按不同指令变成 32 位

### 寄存器与寄存器中的数据（Registers）

- **通用寄存器 r0–r12, sp, lr, pc 都是 32 位**。
- 指令集支持把下列“逻辑类型”放在 32 位寄存器中使用：
  - **32 位指针**（地址宽度 32 位）。
  - **有符号/无符号 32 位整数**。
  - **8/16 位整数（有/无符号）**：放进寄存器时会被**扩展为 32 位**：
    - 无符号 → **零扩展**（高位补 0）
    - 有符号 → **符号扩展**（复制符号位）
  - **64 位整数**：占 **两个 32 位寄存器**（一高一低）。

> 实操提示：在 C 里 `uint8_t/uint16_t` 被装入寄存器后就是 32 位参与运算；编译器会自动插入零扩展/符号扩展。

### 访存指令与扩展（Load/Store）

- **按字节/半字/字** 访问：
  - 读：`LDRB`(零扩展 8)、`LDRH`(零扩展 16)、`LDRSB`(符号扩展 8)、`LDRSH`(符号扩展 16)、`LDR`(32)
  - 写：`STRB`(8)、`STRH`(16)、`STR`(32) ——写入时只看寄存器的低 8/16/32 位
- **批量/双字访存**：
  - 多寄存器：`LDM/STM`（含 `PUSH/POP` 的别名形式）
  - **双字**：`LDRD/STRD`（一次搬 64 位，使用一对寄存器）

> 选择 **LDRSB/LDRSH** vs **LDRB/LDRH** 是“有/无符号”的关键：拿错会让负数变成大正数（经典 Bug）。

###  有符号/无符号的数值范围（Two’s complement）

- **无符号 N 位**：`0 … 2^N − 1`
- **有符号 N 位**（二补码）：`−2^(N−1) … 2^(N−1) − 1`
  - 例如 8 位有符号：`−128 … +127`

### 64 位整数支持与常见写法

- **直接的 64 位指令很有限**：大多数 64 位操作需要**多条指令**拼接。

- 常用套路：

  - **64 位加法**（低 32 先加，带进位再加高 32）

    ```
    // (r1:r0) += (r3:r2)   ; 低位在 r0/r2，高位在 r1/r3
    ADDS r0, r0, r2   // 低 32 位，加并更新进位
    ADC  r1, r1, r3   // 高 32 位 + 进位
    ```

  - **64 位减法**：`SUBS` 低位 + `SBC` 高位

  - **32×32→64 乘法**：有**长乘**指令 `UMULL/SMULL`（无符号/有符号），结果直接落两寄存器；乘加用 `UMLAL/SMLAL`。

  - **64 位乘/除/移位**：一般由编译器生成指令序列或调用软库（如 `__aeabi_lmul` 等）。

- **装/存 64 位**：用 `LDRD/STRD`，或 `LDM/STM` 两个寄存器一起搬。

> **原子性提醒**：Armv7-M 没有“原子 64 位读写”指令；`LDRD/STRD` 不是不可分割原子操作。需要原子更新 64 位变量时，应关中断/用临界区/用互斥（或拆成 32 位原子）。

### 算术在 M 内核上的现实

- **运算基宽是 32 位**：大部分算术/逻辑指令都以 32 位为单位；8/16 位运算通常是对 32 位操作后再掩码。
- **性能与代码密度**：Thumb-2 会在需要时选 32 位“宽指令”（例如带进位、复杂寻址），不必手写 ARM 模式。
- **对齐与双字**：`LDRD/STRD` 期望对齐（未对齐性能差甚至硬 Fault，视实现与设置而定）；建议 8 字节对齐的 64 位对象。

### 与 ABI/编译器的关系（会遇到的）

- **参数/返回**：AAPCS 规定 64 位整数参数/返回值用**寄存器对**（如返回放 `r0:r1`），超出部分走栈。

- **常用编译选项（M7）**：

  ```
  -mcpu=cortex-m7 -mthumb -O2 \
  -mfpu=fpv5-sp-d16|fpv5-d16 -mfloat-abi=hard
  ```

  > 这里 FPU 只影响浮点，不改变整型数据规则。

------

小结

- **内存：8/16/32**；**寄存器：32 位**；**64 位＝两寄存器**。
- **装载即扩展**：选对 `LDRB/LDRH/LDRSB/LDRSH`，避免符号错误。
- **64 位算术要拼**：用 `ADDS+ADC`、`SUBS+SBC`、`UMULL/SMULL`；原子更新需临界区。
- **双字搬运用 LDRD/STRD 或 LDM/STM**，并保证对齐与配对寄存器使用。

![image-20250927235603206](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250927235603206.png)

## 饱和算数

**饱和算术**：当运算结果超出数据类型可表示范围时，不按 2N2^N2N 回绕，而是被**钳制**到上下界（最大/最小值；部分指令同时置饱和标志 Q）。

- **普通整数溢出**（按 2^N 取模）会“绕回去”。
   比如 8 位有符号：`120 + 120 = 240`，按 8 位二补码会变成 **-16**（溢出 wrap-around）。
- **饱和算术**不会绕回：结果被**夹紧到可表示范围的上下界**。
   同例在 8 位有符号范围 [-128, 127] 内：`120 + 120` 被**夹到 127**；
   8 位无符号范围 [0, 255] 内：`250 + 30` 被**夹到 255**。

某些 ARM 指令是“带饱和”的；手册用 `SignedSat(Q)` / `UnsignedSat(Q)` 这类**伪代码函数**来精确定义“**先算** → **再按 N 位上下界夹紧**（并可报告是否饱和）”的行为。实际硬件上，发生饱和还会通过 **Q 标志**反映出来。

![image-20250928002329628](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250928002329628.png)

## ARM核心寄存器（R0-R15重要）

- 13个通用的寄存器，R0-R12  
- 3个具有特殊名称的寄存器和使用模式的寄存器 （SP LR PC）

### SP（Stack Pointer，R13）

- 指向**当前活动栈顶**。Cortex-M 有两套栈：**MSP**（Main Stack）和 **PSP**（Process Stack）；`SP` 这个别名指向“当前选中的那一个”。
  - **上电复位**：从向量表第 0 项装载 **MSP 初值**，并默认使用 **MSP**。
  - **Thread 模式**可用 `CONTROL.SPSEL` 选择 PSP；**Handler 模式（所有异常）始终用 MSP**。
- AAPCS 要求：在任何公共接口处 **SP 必须 8 字节对齐**。
- 指令限制：`PUSH/POP`、`STM/ LDM` 会隐式更新 SP；把 SP 当一般算术寄存器使用是受限的（详见“将 R13 作为寄存器号的用法限制”）。

### LR（Link Register，R14）

- **子程序返回链接寄存器**：执行 `BL/BLX` 时，**返回地址**会写入 LR。Thumb 状态下该地址最低位为 1（表示 Thumb）。
- **复位时 LR=0xFFFFFFFF**：若程序直接“用它返回”，会触发 Fault（用于防呆）。
- **异常入口**：硬件把 **EXC_RETURN 常量**（形如 `0xFFFFFFF1/…F9/FD`）写入 LR，编码了“从哪种栈返回、是否有浮点上下文”等。执行 `BX LR` 时，硬件据此执行**异常返回**。
- 当不需要作返回链接时，**LR 也可充当通用暂存寄存器**（但被调函数要负责恢复它）。

### PC（Program Counter，R15）

- **程序计数器**。复位时从向量表第 1 项装载 **Reset Handler 地址**到 PC。Cortex-M 只运行 **Thumb/Thumb-2**，PC 的目标地址**最低位必须为 1**（非 1 会触发 UsageFault，硬件取指时会忽略该位）。
- **读取 PC** 时得到的是“当前指令地址 + 4”的值（因流水线预取）；**写 PC** 等价于分支跳转（如 `BX/BLX/POP {…,pc}`、`LDR pc,[addr]`）。
- 把 `R15`当作一般寄存器有多项限制，具体见手册相应条目。

**实用小结**

- 复位：`MSP ← VTOR[0]`，`PC ← VTOR[1]`，`LR ← 0xFFFFFFFF`。
- 应用在 **Thread 模式**常用 **PSP**，内核/异常在 **Handler 模式**用 **MSP**。
- 返回路径：普通函数 `POP {…, pc}` 或 `BX lr`；异常返回用装在 LR 里的 **EXC_RETURN** + `BX lr`。
- 始终保持 **SP 8 字节对齐**，并正确保存/恢复 LR 与需要的寄存器，以满足 **AAPCS**。

![image-20250928002955490](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250928002955490.png)

## 应用程序状态寄存器(APSR)

**The Application Program Status Register (APSR)**

### APSR 位分布（Armv7-M）

- **N[31]**：负号标志。结果视作有符号数时，N=结果的 bit31。
- **Z[30]**：零标志。结果为 0 → Z=1，否则 0。
- **C[29]**：进位/不借位标志。加法的**无符号进位**或减法的**不借位**置 1；与有符号溢出（V）不同。
- **V[28]**：有符号溢出标志。加/减后结果超出有符号范围（例如正+正得负，负+负得正）置 1。
- **Q[27]**：**饱和标志**（sticky）。执行 `SSAT/USAT`、`QADD/QSUB/...` 等发生饱和时置 1，**保持为 1 直到软件清零**（`MSR APSR_nzcvq, Rn` 写 0 到 Q）。
- **GE[19:16]**（仅带 **DSP 扩展**的内核，如 Cortex-M7）：**Greater-or-Equal** 标志组，按**并行字节/半字**记录比较或算术每个“lane”的≥关系，供 `SEL` 等 SIMD 指令按位选择。无 DSP 的核上这些位保留。
- 其他位 **Reserved**：为系统保留/未来扩展；应用读出时**忽略**，写入时必须**保持原值**（UNK/SBZP 语义）。

### 谁会更新这些标志

- 绝大多数算术/逻辑指令的 **S** 版本、比较/测试指令：`ADDS/SUBS/ANDS/ORRS/EORS/CMP/CMN/TST/TEQ` 等。
- 移位立即数会把移出的最后一位写到 **C**。
- **饱和/并行**指令会更新 **Q**，部分 SIMD 会更新 **GE**。
- 普通乘法通常不改 NZCV（除非带 S 的特定形式）。

### C 与 V 的快速区分

- **C** 看“无符号进位/不借位”；**V** 看“有符号溢出”。
  - 例：`0xFFFFFFFF + 1` → C=1（进位），V=0（无符号正常，有符号从 −1 到 0 没溢出）。
  - 例：`0x7FFFFFFF + 1` → C=0，**V=1**（正溢出）。

### 使用小贴士

- 比较用 `CMP`：等价于 `SUBS` 只写标志（常用 `BEQ/BNE/BCC/BCS/BMI/BPL/BVS/BVC` 分支）。
- 发生饱和后如果要继续“干净”地运算，**别忘清 Q**：`MSR APSR_nzcvq, #0`。
- 需要按字节/半字做条件选择时，先用 SIMD 指令更新 **GE**，再用 `SEL` 依据 GE 逐 lane 选数。

![image-20250928004353782](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250928004353782.png)

## “系统相关事件”与异常/中断机制

### 系统相关的异常类型

- **SVC（Supervisor Call）**：应用在 **Thread 模式、非特权**时，用 `SVC` 指令**同步**陷入内核，请求特权服务（系统调用）。
- **Fault（故障类异常）**：
  - **取指错误**（指令访问相关，如取指到不可执行区域）。
  - **数据访问错误**（任意 `load/store` 的存储器访问出错，如总线/MPU 违规）。
  - **UsageFault**（执行状态错误，如**未定义指令**、非法状态、除零等）。
  - **DebugMonitor**（调试事件引发的监控异常）。
     这些故障通常与导致它的那条指令**同步**发生；但也有**不精确异常**（例如写缓冲延迟导致的总线错误，报告时间与致因指令不严格对应）。
- **Interrupt（外部中断）**：始终被处理器视为**异步**于程序流（由 NVIC 管理）。

> 精确 vs 不精确：精确异常能指向“当前指令”；不精确异常可能在之后才报告（典型：缓冲写导致的 BusFault）。

### 两个内置系统异常（OS 高频使用）

- **SysTick**：片内系统定时器及其中断（节拍、调度心跳、时间片等）。
- **PendSV（延迟的 SVC）**：
  - 不是用指令触发，而是**软件置位** `ICSR.PENDSVSET=1` 让异常**挂起**；何时被处理取决于**优先级模型**。
  - 常用法：**把 PendSV 设为最低优先级**，在需要“安全点”时再切任务（上下文切换）。
  - 典型调度路径：**SysTick/外部中断**里决定需要切换 → 置位 **PendSV** → 中断返回时进入 **PendSV Handler** 执行上下文切换。
  - **SVC vs PendSV**：`SVC` 是**同步立即**陷入；**PendSV** 是**延迟到合适时机**再处理，避免在关键区打断。

简要代码：

```
// 触发 PendSV
SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;

// 触发 SVC（同步）
__asm volatile ("svc #0");
```

### NVIC：外部中断控制器

- 负责外设中断的**使能/挂起/清除/优先级**，决定中断/异常的抢占关系与响应次序。

### 调试相关

- **BKPT** 指令会生成调试事件（通常进入 DebugMonitor 或由调试器捕获）。

### 低功耗/同步提示指令

- **WFI（Wait For Interrupt）**：等待**中断**唤醒；常用于省电/空闲。
- **WFE（Wait For Event）** 和 **SEV（Send Event）**：事件机制；
  - `SEV` 置位“事件寄存器”，使下一条 `WFE` **不休眠直接返回**；
  - `WFE` 既可被事件唤醒，也可被中断唤醒，适合**任务间轻量提示/省电**。
  - 常见配套：在进入 `WFI/WFE` 前做一次 **DSB/ISB**，避免竞态。

### 运行模式与特权回顾（与上述机制如何协作）

- **Thread 模式**：应用运行的基础模式，可**特权或非特权**；复位进入此模式。
- **Handler 模式**：处理**所有异常**，**总是特权**。
- 非特权应用需要系统服务 → `SVC` 同步进入 **Handler**；调度/上下文切换 → 借助 **PendSV** 延迟处理。

**一句话总结**：
 Armv7-M 提供了 SVC、Fault、SysTick、PendSV、NVIC、BKPT 以及 WFI/WFE/SEV 等机制，支撑“**应用非特权运行 + 通过 SVC 请求内核服务 + 用 PendSV 在合适时机做调度/切换 + NVIC 管外部中断 + 低功耗等待**”这一整套现代嵌入式 OS 运行模型。

![image-20250928005426073](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250928005426073.png)![image-20250928005442693](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250928005442693.png)
