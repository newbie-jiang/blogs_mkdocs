## GPIOé©±åŠ¨æ¡†æ¶åˆ†æï¼Œé¡¶å±‚åˆ°åº•å±‚

gpioç¤ºä¾‹åˆ†æ      zephyr\samples\basic\blinky\src\main.c        ä½¿ç”¨stm32

```c
#include <stdio.h>
#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>

/* 1000 msec = 1 sec */
#define SLEEP_TIME_MS   1000

/* The devicetree node identifier for the "led0" alias. */
#define LED0_NODE DT_ALIAS(led0)

/*
 * A build error on this line means your board is unsupported.
 * See the sample documentation for information on how to fix this.
 */
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

int main(void)
{
	int ret;
	bool led_state = true;

	if (!gpio_is_ready_dt(&led)) {
		return 0;
	}

	ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
	if (ret < 0) {
		return 0;
	}

	while (1) {
		ret = gpio_pin_toggle_dt(&led);
		if (ret < 0) {
			return 0;
		}

		led_state = !led_state;
		printf("LED state: %s\n", led_state ? "ON" : "OFF");
		k_msleep(SLEEP_TIME_MS);  
	}
	return 0;
}
```

ä½¿ç”¨ä¸Šè¿°ä¸­çš„ç¤ºä¾‹ï¼Œåˆ†æGPIOçš„é©±åŠ¨æ¡†æ¶

## ç¬¬ä¸€å±‚   

zephyr\samples\basic\blinky\src\main.c

```
gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE); 
```

åº”ç”¨å±‚æŠ½è±¡ (Devicetree å°è£…)

- æŠŠ **è®¾å¤‡æ ‘ï¼ˆDevicetreeï¼‰ä¸­å®šä¹‰çš„ GPIO æ§åˆ¶å™¨ã€å¼•è„šå·ã€æ ‡å¿—ä½** ç»„åˆä¸ºä¸€ä¸ª `gpio_dt_spec` å¯¹è±¡

- è°ƒç”¨ `gpio_pin_configure()`ï¼Œä¼ å…¥ç»“æ„ä½“ä¸­æå–çš„ `port`ã€`pin`ã€`flags`

- å®ç°å¹³å°æ— å…³ã€å¼•è„šæŠ½è±¡ã€åº”ç”¨é€»è¾‘æ¸…æ™°

```c
struct gpio_dt_spec {
	/** GPIO device controlling the pin */
	const struct device *port;
	/** The pin's number on the device */
	gpio_pin_t pin;
	/** The pin's configuration flags as specified in devicetree */
	gpio_dt_flags_t dt_flags;
};

static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
	return gpio_pin_configure(spec->port,
				  spec->pin,
				  spec->dt_flags | extra_flags);
}
```

## ç¬¬äºŒå±‚

zephyr\build\zephyr\include\generated\zephyr\syscalls\gpio.h

```c
static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
```

é€šç”¨å­ç³»ç»Ÿæ¥å£ (GPIO API å±‚)

- é€šè¿‡ `z_impl_gpio_pin_configure()` å®ç° **é€»è¾‘æ ¡éªŒã€å‚æ•°è§„èŒƒåŒ–å¤„ç†**

- æ˜¯æ‰€æœ‰ GPIO å­ç³»ç»Ÿçš„ç»Ÿä¸€æ¥å£ï¼Œæä¾›ä¸€è‡´æ€§ï¼ˆæ— è®ºä½ æ˜¯ STM32 è¿˜æ˜¯ Nordicï¼‰

- #### ç‰¹æ€§ï¼š

    æ£€æŸ¥ flag åˆæ³•æ€§ï¼ˆä¸èƒ½åŒæ—¶ä¸Šæ‹‰å’Œä¸‹æ‹‰ã€ä¸èƒ½æ—¢è¾“å‡ºé«˜åˆè¾“å‡ºä½ç­‰ï¼‰

    å¤„ç† `GPIO_ACTIVE_LOW` / `GPIO_OUTPUT_INIT_LOGICAL` ç­‰ç‰¹æ®Šæƒ…å†µ

    è®¾ç½®è¿è¡Œæ—¶æ•°æ®ç»“æ„ `invert` ä½

     è°ƒç”¨ç¬¬ä¸‰å±‚é©±åŠ¨æ¥å£è¡¨ä¸­çš„å‡½æ•°æŒ‡é’ˆ

```c
/**
 * @brief Runtime device structure (in ROM) per driver instance
 */
struct device {
	/** Name of the device instance */
	const char *name;
	/** Address of device instance config information */
	const void *config;
	/** Address of the API structure exposed by the device instance */
	const void *api;
	/** Address of the common device state */
	struct device_state *state;
	/** Address of the device instance private data */
	void *data;
	/** Device operations */
	struct device_ops ops;
	/** Device flags */
	device_flags_t flags;
#if defined(CONFIG_DEVICE_DEPS) || defined(__DOXYGEN__)
	/**
	 * Optional pointer to dependencies associated with the device.
	 *
	 * This encodes a sequence of sets of device handles that have some
	 * relationship to this node. The individual sets are extracted with
	 * dedicated API, such as device_required_handles_get(). Only available
	 * if @kconfig{CONFIG_DEVICE_DEPS} is enabled.
	 */
	Z_DEVICE_DEPS_CONST device_handle_t *deps;
#endif /* CONFIG_DEVICE_DEPS */
#if defined(CONFIG_PM_DEVICE) || defined(__DOXYGEN__)
	/**
	 * Reference to the device PM resources (only available if
	 * @kconfig{CONFIG_PM_DEVICE} is enabled).
	 */
	union {
		struct pm_device_base *pm_base;
		struct pm_device *pm;
		struct pm_device_isr *pm_isr;
	};
#endif
#if defined(CONFIG_DEVICE_DT_METADATA) || defined(__DOXYGEN__)
	const struct device_dt_metadata *dt_meta;
#endif /* CONFIG_DEVICE_DT_METADATA */
};


typedef uint8_t gpio_pin_t;
typedef uint32_t gpio_flags_t;

#define compiler_barrier() do { \
	__asm__ __volatile__ ("" ::: "memory"); \
} while (false)


__syscall int gpio_pin_configure(const struct device *port,
				 gpio_pin_t pin,
				 gpio_flags_t flags);


static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
{
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
		union { uintptr_t x; const struct device * val; } parm0 = { .val = port };
		union { uintptr_t x; gpio_pin_t val; } parm1 = { .val = pin };
		union { uintptr_t x; gpio_flags_t val; } parm2 = { .val = flags };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_GPIO_PIN_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_configure(port, pin, flags);
}
```

## ç¬¬ä¸‰å±‚

zephyr\include\zephyr\drivers\gpio.h

```c
static inline int z_impl_gpio_pin_configure(const struct device *port,
					    gpio_pin_t pin,
					    gpio_flags_t flags)
```

é©±åŠ¨ç»‘å®šæ¥å£ï¼ˆé©±åŠ¨å‡½æ•°è¡¨ï¼‰

- å®šä¹‰ `gpio_driver_api` çš„ç»“æ„ä½“ï¼ŒæŠŠåº•å±‚é©±åŠ¨å‡½æ•°å¡«è¿›å»

- æ³¨å†Œé©±åŠ¨å‡½æ•°è¡¨ï¼ˆå‡½æ•°æŒ‡é’ˆè¡¨ï¼‰ä¾›ç³»ç»Ÿç»Ÿä¸€è°ƒåº¦

- è®©ä¸åŒèŠ¯ç‰‡å‚å•†çš„ GPIO é©±åŠ¨ï¼Œéƒ½èƒ½ç»Ÿä¸€æ¥å…¥ Zephyr API

```c
__subsystem struct gpio_driver_api {
	int (*pin_configure)(const struct device *port, gpio_pin_t pin,
			     gpio_flags_t flags);
#ifdef CONFIG_GPIO_GET_CONFIG
	int (*pin_get_config)(const struct device *port, gpio_pin_t pin,
			      gpio_flags_t *flags);
#endif
	int (*port_get_raw)(const struct device *port,
			    gpio_port_value_t *value);
	int (*port_set_masked_raw)(const struct device *port,
				   gpio_port_pins_t mask,
				   gpio_port_value_t value);
	int (*port_set_bits_raw)(const struct device *port,
				 gpio_port_pins_t pins);
	int (*port_clear_bits_raw)(const struct device *port,
				   gpio_port_pins_t pins);
	int (*port_toggle_bits)(const struct device *port,
				gpio_port_pins_t pins);
	int (*pin_interrupt_configure)(const struct device *port,
				       gpio_pin_t pin,
				       enum gpio_int_mode mode,
				       enum gpio_int_trig trig);
	int (*manage_callback)(const struct device *port,
			       struct gpio_callback *cb,
			       bool set);
	uint32_t (*get_pending_int)(const struct device *dev);
#ifdef CONFIG_GPIO_GET_DIRECTION
	int (*port_get_direction)(const struct device *port, gpio_port_pins_t map,
				  gpio_port_pins_t *inputs, gpio_port_pins_t *outputs);
#endif /* CONFIG_GPIO_GET_DIRECTION */
};


static DEVICE_API(gpio, gpio_stm32_driver) = {
	.pin_configure = gpio_stm32_config,
#if defined(CONFIG_GPIO_GET_CONFIG) && !defined(CONFIG_SOC_SERIES_STM32F1X)
	.pin_get_config = gpio_stm32_get_config,
#endif /* CONFIG_GPIO_GET_CONFIG */
	.port_get_raw = gpio_stm32_port_get_raw,
	.port_set_masked_raw = gpio_stm32_port_set_masked_raw,
	.port_set_bits_raw = gpio_stm32_port_set_bits_raw,
	.port_clear_bits_raw = gpio_stm32_port_clear_bits_raw,
	.port_toggle_bits = gpio_stm32_port_toggle_bits,
	.pin_interrupt_configure = gpio_stm32_pin_interrupt_configure,
	.manage_callback = gpio_stm32_manage_callback,
};

static inline int z_impl_gpio_pin_configure(const struct device *port,
					    gpio_pin_t pin,
					    gpio_flags_t flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	__unused const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
		(struct gpio_driver_data *)port->data;
	int ret;

	SYS_PORT_TRACING_FUNC_ENTER(gpio_pin, configure, port, pin, flags);

	__ASSERT((flags & GPIO_INT_MASK) == 0,
		 "Interrupt flags are not supported");

	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
		 (GPIO_PULL_UP | GPIO_PULL_DOWN),
		 "Pull Up and Pull Down should not be enabled simultaneously");

	__ASSERT(!((flags & GPIO_INPUT) && !(flags & GPIO_OUTPUT) && (flags & GPIO_SINGLE_ENDED)),
		 "Input cannot be enabled for 'Open Drain', 'Open Source' modes without Output");

	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
			(flags & GPIO_LINE_OPEN_DRAIN) == 0);

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
		 || (flags & GPIO_OUTPUT) != 0,
		 "Output needs to be enabled to be initialized low or high");

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
		 != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
		 "Output cannot be initialized low and high");

	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
	}

	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	ret = api->pin_configure(port, pin, flags);
	SYS_PORT_TRACING_FUNC_EXIT(gpio_pin, configure, port, pin, ret);
	return ret;
}
```

è°ƒç”¨ 	**ret = api->pin_configure(port, pin, flags);**   è¿›å…¥ä¸‹ä¸€å±‚

## ç¬¬å››å±‚

zephyr\drivers\gpio\gpio_stm32.c

```c
static int gpio_stm32_config(const struct device *dev,
			     gpio_pin_t pin, gpio_flags_t flags)
```

- ç¡¬ä»¶é©±åŠ¨å®ç°ï¼ˆèŠ¯ç‰‡å‚å•†ç›¸å…³ä»£ç ï¼‰

```c
/**
 * @brief Configure pin or port
 */
static int gpio_stm32_config(const struct device *dev,
			     gpio_pin_t pin, gpio_flags_t flags)
{
	int err;
	uint32_t pincfg;
	struct gpio_stm32_data *data = dev->data;

	/* figure out if we can map the requested GPIO
	 * configuration
	 */
	err = gpio_stm32_flags_to_conf(flags, &pincfg);
	if (err != 0) {
		return err;
	}

	/* Enable device clock before configuration (requires bank writes) */
	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
	    !(data->pin_has_clock_enabled & BIT(pin))) {
		err = pm_device_runtime_get(dev);
		if (err < 0) {
			return err;
		}
		data->pin_has_clock_enabled |= BIT(pin);
	}

	if ((flags & GPIO_OUTPUT) != 0) {
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
		}
	}

	gpio_stm32_configure_raw(dev, pin, pincfg, 0);

#ifdef CONFIG_STM32_WKUP_PINS
	if (flags & STM32_GPIO_WKUP) {
#ifdef CONFIG_POWEROFF
		struct gpio_dt_spec gpio_dt_cfg = {
			.port = dev,
			.pin = pin,
			.dt_flags = (gpio_dt_flags_t)flags,
		};

		if (stm32_pwr_wkup_pin_cfg_gpio((const struct gpio_dt_spec *)&gpio_dt_cfg)) {
			LOG_ERR("Could not configure GPIO %s pin %d as a wake-up source",
					gpio_dt_cfg.port->name, gpio_dt_cfg.pin);
		}
#else
		LOG_DBG("STM32_GPIO_WKUP flag has no effect when CONFIG_POWEROFF=n");
#endif /* CONFIG_POWEROFF */
	}
#endif /* CONFIG_STM32_WKUP_PINS */

	/* Decrement GPIO usage count only if pin is now disconnected after being connected */
	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
	    (data->pin_has_clock_enabled & BIT(pin))) {
		err = pm_device_runtime_put(dev);
		if (err < 0) {
			return err;
		}
		data->pin_has_clock_enabled &= ~BIT(pin);
	}

	return 0;
}
```



## syscall æœºåˆ¶

å‚è€ƒé“¾æ¥ï¼šhttps://www.cnblogs.com/ttwards/p/18449137



ä¸Šè¿°ä¸­å‘ç°ï¼Œå‡½æ•°  gpio_pin_configure   è·¯å¾„ä¸º    zephyr\build\zephyr\include\generated\zephyr\syscalls\gpio.h

```c
static inline int gpio_pin_configure(const struct device * port, gpio_pin_t pin, gpio_flags_t flags)
```

 zephyr\build è¿™ä¸ªè·¯å¾„æ˜¯ç¼–è¯‘åçš„è·¯å¾„ï¼Œéš¾é“æ˜¯ç¼–è¯‘å…ˆç”Ÿæˆ gpio.hæ–‡ä»¶   å†ç»§ç»­ç¼–è¯‘ ï¼Ÿ

- å‡½æ•° **ä¸æ˜¯ç”±å†™çš„ä»£ç è‡ªåŠ¨ç”Ÿæˆçš„**ï¼Œè€Œæ˜¯ç”± Zephyr çš„ syscall æœºåˆ¶ **ç”Ÿæˆäº†ä¸€ä¸ªå°è£…ç‰ˆæœ¬**

- Zephyr æ”¯æŒç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„åˆ†ç¦»ï¼Œç”¨æˆ·ç©ºé—´ä»£ç ä¸èƒ½ç›´æ¥è°ƒç”¨å†…æ ¸ç©ºé—´çš„å‡½æ•°ã€‚

ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼ŒZephyr ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æœºåˆ¶ï¼Œå…è®¸ç”¨æˆ·ç©ºé—´ä»£ç é€šè¿‡ç‰¹å®šçš„æ¥å£è°ƒç”¨å†…æ ¸ç©ºé—´çš„å‡½æ•°ã€‚è¿™æ ·ä¹Ÿæå‡äº†ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

`__syscall` å…³é”®å­—ç”¨äºæ ‡è®°ä¸€ä¸ªå‡½æ•°ä¸ºç³»ç»Ÿè°ƒç”¨å‡½æ•°ã€‚å®ƒå‘Šè¯‰ç¼–è¯‘å™¨å’Œ [`gen_syscalls.py`](https://github.com/zephyrproject-rtos/zephyr/blob/main/scripts/build/gen_syscalls.py) è„šæœ¬ï¼Œè¿™ä¸ªå‡½æ•°éœ€è¦ç”Ÿæˆç³»ç»Ÿè°ƒç”¨æ¥å£

`gen_syscalls.py` è„šæœ¬ä¼šç”Ÿæˆä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºåœ¨ç”¨æˆ·ç©ºé—´è°ƒç”¨è¯¥ç³»ç»Ÿè°ƒç”¨å‡½æ•°ã€‚
è¿™ä¸ªå†…è”å‡½æ•°ä¼šæ£€æŸ¥æ˜¯å¦åœ¨ç”¨æˆ·ç©ºé—´ç¯å¢ƒä¸‹è¿è¡Œï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é€šè¿‡ç³»ç»Ÿè°ƒç”¨æœºåˆ¶è½¬å‘åˆ°å†…æ ¸ç©ºé—´çš„å‡½æ•°ã€‚



Zephyr çš„ syscall æœºåˆ¶å¦‚ä½•å·¥ä½œï¼Ÿ

å½“åœ¨ Zephyr ä¸­å†™ä¸‹ï¼š

```
__syscall int gpio_pin_configure(const struct device *port, gpio_pin_t pin, gpio_flags_t flags);
```

è¿™æ¡å£°æ˜å‘Šè¯‰ Zephyrï¼š

> â€œè¿™æ˜¯ä¸€ä¸ªæ”¯æŒ**ç”¨æˆ·ç©ºé—´è°ƒç”¨**çš„ APIï¼Œæˆ‘å¸Œæœ›å®ƒèƒ½åœ¨ç”¨æˆ·æ€æˆ–å†…æ ¸æ€éƒ½å®‰å…¨è¿è¡Œã€‚â€

ç„¶åæ„å»ºç³»ç»Ÿï¼ˆå€ŸåŠ© Python è„šæœ¬ã€CMake å’Œ devicetree ç¼–è¯‘å™¨ï¼‰ä¼šï¼š

1. **ç”Ÿæˆ syscall è·³è½¬ä»£ç **
2. **ç”Ÿæˆ `z_impl_gpio_pin_configure()` çš„è°ƒç”¨å°è£…**
3. **ç”Ÿæˆä¸€ä¸ªå°è£…çš„ inline å‡½æ•°ï¼Œæ”¾å…¥ `build/zephyr/include/generated/zephyr/syscalls/gpio.h`**

------

ğŸ§  æ‰€ä»¥ä½ çœ‹åˆ°çš„è¿™ä¸ªå‡½æ•°ï¼š

```
static inline int gpio_pin_configure(const struct device *port,
				     gpio_pin_t pin,
				     gpio_flags_t flags)
{
	return z_impl_gpio_pin_configure(port, pin, flags);
}
```

 **è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå±äºâ€œsyscall wrapperâ€**ï¼Œå®ƒçš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ª **dispatcher å‡½æ•°**ã€‚

------

ğŸ” è‡ªåŠ¨ç”Ÿæˆçš„è·¯å¾„ç»“æ„å¦‚ä¸‹ï¼š

```
build/
â””â”€â”€ zephyr/
    â””â”€â”€ include/
        â””â”€â”€ generated/
            â””â”€â”€ zephyr/
                â””â”€â”€ syscalls/
                    â””â”€â”€ gpio.h    â† â˜…çœ‹åˆ°çš„é‚£ä¸ª
```

é‡Œé¢åŒ…å«æ‰€æœ‰å¸¦æœ‰ `__syscall` çš„ API çš„è‡ªåŠ¨å°è£…ã€‚

------

âœ… ä¸ºä»€ä¹ˆ Zephyr è¦è¿™ä¹ˆåšï¼Ÿ

è¿™æ˜¯ä¸ºäº†æ”¯æŒè¿™ä¸¤ä¸ªæ ¸å¿ƒèƒ½åŠ›ï¼š

| åœºæ™¯                 | è¡Œä¸º                                                     |
| -------------------- | -------------------------------------------------------- |
| **å†…æ ¸çº¿ç¨‹**è°ƒç”¨ API | ç›´æ¥ inline è°ƒç”¨ `z_impl_gpio_pin_configure()`ï¼ˆé«˜æ•ˆï¼‰   |
| **ç”¨æˆ·çº¿ç¨‹**è°ƒç”¨ API | è‡ªåŠ¨é€šè¿‡ `arch_syscall_invokeX()` è¿›å…¥å†…æ ¸ï¼ˆéš”ç¦»ã€å®‰å…¨ï¼‰ |

æ‰€ä»¥è‡ªåŠ¨ç”Ÿæˆçš„è¿™ä¸ªå°è£…å‡½æ•°ï¼Œå…¶ä½œç”¨å°±æ˜¯ç»Ÿä¸€å°è£…è·¯å¾„ï¼Œ**ç¡®ä¿ syscall è°ƒåº¦æœºåˆ¶æ­£ç¡®æ— è¯¯ä¸”é«˜æ•ˆè¿è¡Œ**ã€‚

