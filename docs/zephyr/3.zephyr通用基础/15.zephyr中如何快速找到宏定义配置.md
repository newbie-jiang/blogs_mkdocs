



拿文件系统来说，

- 查看文件系统的kconfig文件 （最直接）
- 看文件系统的cmake文件
- 看子系统的测试（使用时可以参考）（属于 **Zephyr 的自动化测试用例** 配置文件，不是普通的示例，维护人员相关的测试。）

![image-20250830014202604](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250830014202604.png)

![image-20250814211340317](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250814211340317.png)

Z:\zephyrproject\zephyr\subsys\fs\CMakeLists.txt

```
# SPDX-License-Identifier: Apache-2.0

if(CONFIG_FILE_SYSTEM_LIB_LINK)
  zephyr_interface_library_named(FS)

  if(CONFIG_FILE_SYSTEM)
    zephyr_library()
    zephyr_library_include_directories(${CMAKE_CURRENT_SOURCE_DIR})
    zephyr_library_sources(fs.c fs_impl.c)
    zephyr_library_sources_ifdef(CONFIG_FAT_FILESYSTEM_ELM   fat_fs.c)
    zephyr_library_sources_ifdef(CONFIG_FILE_SYSTEM_LITTLEFS littlefs_fs.c)
    zephyr_library_sources_ifdef(CONFIG_FILE_SYSTEM_SHELL    shell.c)

    zephyr_library_compile_definitions_ifdef(CONFIG_FILE_SYSTEM_LITTLEFS
                                            LFS_CONFIG=zephyr_lfs_config.h
    )
  endif()

  add_subdirectory_ifdef(CONFIG_FILE_SYSTEM_EXT2 ext2)
  add_subdirectory_ifdef(CONFIG_FUSE_CLIENT fuse_client)
  add_subdirectory_ifdef(CONFIG_FILE_SYSTEM_VIRTIOFS virtiofs)

  zephyr_library_link_libraries(FS)

  target_link_libraries_ifdef(CONFIG_FAT_FILESYSTEM_ELM   FS INTERFACE ELMFAT)
  target_link_libraries_ifdef(CONFIG_FILE_SYSTEM_LITTLEFS FS INTERFACE LITTLEFS)
  target_link_libraries_ifdef(CONFIG_FILE_SYSTEM_EXT2     FS INTERFACE EXT2)
  target_link_libraries_ifdef(CONFIG_FUSE_CLIENT          FS INTERFACE FUSE_CLIENT)
  target_link_libraries_ifdef(CONFIG_FILE_SYSTEM_VIRTIOFS FS INTERFACE VIRTIOFS)
endif()

add_subdirectory_ifdef(CONFIG_FCB  ./fcb)
add_subdirectory_ifdef(CONFIG_NVS  ./nvs)
add_subdirectory_ifdef(CONFIG_ZMS  ./zms)

if(CONFIG_FUSE_FS_ACCESS)
  zephyr_library_named(FS_FUSE)
  find_package(PkgConfig REQUIRED)
  pkg_search_module(FUSE REQUIRED fuse)
  zephyr_include_directories(${FUSE_INCLUDE_DIRS})
  target_link_options(native_simulator INTERFACE "-l${FUSE_LIBRARIES}")
  target_sources(native_simulator INTERFACE fuse_fs_access_bottom.c)
  target_compile_options(native_simulator INTERFACE "-D_FILE_OFFSET_BITS=64")
  zephyr_library_sources(fuse_fs_access.c)
endif()

```



 `subsys/fs/CMakeLists.txt` 就是**编译阶段**根据 `CONFIG_...` 选择**哪些源码参与构建**的“总开关”。
 不过要把全貌搞清楚，建议把三处信息配合起来看：

------

## 1) 谁定义这些 `CONFIG_...`？——看 **Kconfig**

- 源：`subsys/fs/Kconfig`、`subsys/fs/ext2/Kconfig`、`modules/fs/fatfs/Kconfig`、`modules/fs/littlefs/Kconfig` 等。
- 作用：定义 `CONFIG_FILE_SYSTEM`、`CONFIG_FAT_FILESYSTEM_ELM`、`CONFIG_FILE_SYSTEM_LITTLEFS`、`CONFIG_FILE_SYSTEM_EXT2`、`CONFIG_FILE_SYSTEM_MKFS` 等**开关本身**，以及它们的**依赖**和**帮助文本**。
- 实用命令：
  - `west build -t menuconfig`（或 `guiconfig`）交互查看/切换
  - `grep -R "config FILE_SYSTEM_LITTLEFS" zephyr/ modules/` 快速定位定义处

## 2) 这些开关如何影响编译？——看 **CMakeLists.txt**

你贴的这段正是关键逻辑（简化说明）：

- `zephyr_library_sources_ifdef(CONFIG_FAT_FILESYSTEM_ELM fat_fs.c)`
   → 选了 FATFS 就把 `fat_fs.c` 编进来
- `zephyr_library_sources_ifdef(CONFIG_FILE_SYSTEM_LITTLEFS littlefs_fs.c)`
   → 选了 littlefs 就把适配层编进来
- `add_subdirectory_ifdef(CONFIG_FILE_SYSTEM_EXT2 ext2)`
   → 选了 ext2 就进入 `subsys/fs/ext2/` 子目录继续构建
- `target_link_libraries_ifdef(CONFIG_FAT_FILESYSTEM_ELM FS INTERFACE ELMFAT)`
   → 选了 FATFS 就把 **ELMFAT** 模块库链接进来（对应 `modules/fatfs/`）
- `zephyr_library_compile_definitions_ifdef(CONFIG_FILE_SYSTEM_LITTLEFS LFS_CONFIG=zephyr_lfs_config.h)`
   → 给 littlefs 增加了编译宏 `LFS_CONFIG=...`

同样地，ext2、fatfs、littlefs 目录下还有各自的 `CMakeLists.txt`，会继续细分哪些源文件被编译。

## 3) 最终哪些开关是“生效”的？——看 **构建产物**

- `build/zephyr/.config`：Kconfig 的最终结果（人读最方便）
- `build/zephyr/include/generated/autoconf.h`：同样的开关以 `#define CONFIG_xxx` 形式提供给 C 代码
- 想看**究竟哪些文件被编译**：
  - `ninja -v`（在 build 目录）打印所有编译命令
  - 或查 `build/zephyr/compile_commands.json`

------

## 推荐排查/理解套路

1. 在源码里找到这个 `CONFIG_...` 的 **Kconfig 定义**（看依赖/默认值/帮助）。
2. 在相关 **CMakeLists.txt** 看它如何控制 `sources_ifdef / add_subdirectory_ifdef / link_libraries_ifdef`。
3. `menuconfig` 里切换 → 重新构建，检查 `.config` 与 `ninja -v` 的变化。

------

## 常见文件位置一览（方便 grep）

- FATFS：`modules/fatfs/`（ELM FatFs 上游） + `zephyr/modules/fatfs/`（适配层）
- littlefs：`modules/littlefs/` + `subsys/fs/littlefs_fs.c`（适配层）
- ext2：`subsys/fs/ext2/`
- FS 框架：`subsys/fs/`（`fs.c`, `fs_impl.c`, Kconfig，总控 CMake 就在这里）

------

简短结论：
 **Kconfig** 定义“有什么开关/依赖”，**CMake** 决定“开关打开后编哪些源/连什么库”，**.config/autoconf.h** 反映“最后哪些开关真的打开了”。你现在看 CMake 能清楚了解编译条件，配合 Kconfig 和 `.config` 就能把“为何如此”与“是否生效”一并搞清楚。

