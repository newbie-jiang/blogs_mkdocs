# 模块加载参数传递

- 首先理解概念  什么是内核启动参数传递（bootargs）？ 当 Linux 内核启动时，bootloader（如 U-Boot、GRUB）会把一串字符串传给内核



Linux 驱动既可以：

- **内置进内核**（built-in, `y`），参数从 **bootargs** 传入。
- **作为模块加载**（`m`，即 `.ko` 文件），参数通过 **insmod/modprobe** 传入。

今天说的就是 **第二种：模块加载参数**。



下面把 **Linux 内核里用于“模块参数传递”的宏**系统地梳理一遍：用途、原型、常见类型、`sysfs` 行为、示例与注意事项，一看就会用。

# 一、最常用的宏

## 1) `module_param(name, type, perm)`

- **作用**：把一个全局变量暴露为模块参数，名字与变量同名。

- **原型**：`module_param(name, type, perm)`

- **示例**

  ```
  static int debug = 0;
  module_param(debug, int, 0644);        // /sys/module/<mod>/parameters/debug
  MODULE_PARM_DESC(debug, "Enable debug");
  ```

- **加载传参**

  ```
  insmod hello.ko debug=1
  # 或（内置 y 时）
  ... bootargs: hello.debug=1
  ```

## 2) `module_param_named(param_name, var, type, perm)`

- **作用**：对外参数名与内部变量名不同。

- **原型**：`module_param_named(name, variable, type, perm)`

- **示例**

  ```
  static int loglevel = 3;
  module_param_named(debug, loglevel, int, 0644); // 参数名=debug，变量=loglevel
  ```

## 3) `module_param_array(name, type, nump, perm)`

- **作用**：导出一个 **动态长度数组** 参数。

- **原型**：`module_param_array(name, type, nump, perm)`（`nump` 为 *int* 指针，返回实际设置的元素个数，可为 NULL）

- **示例**

  ```
  static int values[8] = {0};
  static int nset;
  module_param_array(values, int, &nset, 0644);
  /* insmod hello.ko values=10,20,30   -> nset=3 */
  ```

## 4) `module_param_array_named(param_name, array, type, nump, perm)`

- **作用**：数组参数 + 自定义外部名字。

- **示例**

  ```
  static int chans[4];
  module_param_array_named(channel, chans, int, NULL, 0444);
  /* insmod hello.ko channel=1,6,11 */
  ```

## 5) `module_param_string(name, string, len, perm)`

- **作用**：暴露一个 **定长字符数组**（不是 `char *` 指针）。

- **原型**：`module_param_string(name, string, len, perm)`

- **示例**

  ```
  static char devname[32] = "hello0";
  module_param_string(name, devname, sizeof(devname), 0644);
  /* insmod hello.ko name=mydev */
  ```

## 6) `module_param_cb(name, &ops, arg, perm)`

- **作用**：自定义 **解析(set)/显示(get)** 行为，适合复杂类型或校验。

- **原型**：`module_param_cb(name, struct kernel_param_ops *ops, void *arg, umode_t perm)`

- **`kernel_param_ops`**

  ```
  static int my_set(const char *val, const struct kernel_param *kp)
  { /* 解析用户字符串 val，写入 kp->arg */ return 0; }
  
  static int my_get(char *buf, const struct kernel_param *kp)
  { /* 把 kp->arg 转成字符串写入 buf */ return scnprintf(buf, PAGE_SIZE, "..."); }
  
  static const struct kernel_param_ops my_ops = { .set = my_set, .get = my_get };
  static int my_val;
  module_param_cb(myparam, &my_ops, &my_val, 0644);
  ```

## 7) `MODULE_PARM_DESC(name, "description")`

- **作用**：给参数加说明，`modinfo xxx.ko` 时可见，也常被文档工具抓取。

- **示例**

  ```
  MODULE_PARM_DESC(values, "List of channel values");
  ```

------

# 二、可用 **类型** 速查（`type` 取值）

常见标识（由内核内置的 `param_ops_*` 支持）：

- **整数类**：`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`s64`、`u64`
- **布尔类**：`bool`（true/false/1/0）、`invbool`（取反语义）
- **字符串**：`charp`（`char *` 指针；注意生命周期）、`module_param_string`（定长数组）

> 小贴士
>
> - 布尔的 `invbool` 常用于“禁用开关”：`insmod foo.ko nofeature=1` 实际置 **false**。
> - 64 位类型在较新内核里有 `s64/u64`，老内核里也常见 `ullong/ulonglong`。

------

# 三、`perm` 权限字段的意义

- 是创建 sysfs 节点 `/sys/module/<mod>/parameters/<param>` 的 **权限位**（`0444` 只读，`0644` 可写）。
- 传 `0` 表示 **不导出到 sysfs**（仍可通过 `insmod`/`bootargs` 设置）。
- 这些权限可能受内核的安全策略/只读文件系统限制；写失败会返回 `-EPERM`。

------

# 四、内置(y) 与 模块(m) 的差异

| 形式         | 传参入口                            | 生效时机 | sysfs 路径                                         |
| ------------ | ----------------------------------- | -------- | -------------------------------------------------- |
| **内置 (y)** | `bootargs`: `<modname>.<param>=...` | 启动早期 | `/sys/module/<modname>/parameters/...`（大多可见） |
| **模块 (m)** | `insmod/modprobe`: `param=...`      | 加载瞬间 | 同上                                               |

> **名字规则**：`module_param` 导出的参数，在 **内置** 场景下需要前缀模块名：`<模块名>.<参数>` 才能从命令行匹配；如果你想**不带模块名前缀**的“全局参数”，请看下面的 `core_param`。

------

# 五、进阶：内核“核心参数”（非必须）

## `core_param(name, var, type, perm)`

- **作用**：注册一个 **不带模块名前缀** 的参数（更“全局”），常用于内核核心/子系统代码。

- **示例**

  ```
  static int panic_timeout = 0;
  core_param(panic, panic_timeout, int, 0644);
  /* bootargs: panic=10  // 无需 <mod>.panic=10 */
  ```

- **注意**：避免与其他名字冲突；普通驱动更推荐 `module_param` 路线。

------

# 六、常见用法模式清单

1. **简单开关 / 数值**

```
static bool enable;
static int level = 3;
module_param(enable, bool, 0644);
module_param(level, int, 0644);
```

1. **数组**

```
static u32 coeffs[4] = {1,2,3,4};
static int n;
module_param_array(coeffs, uint, &n, 0644);
```

1. **重命名**

```
static int timeout_ms = 1000;
module_param_named(timeout, timeout_ms, int, 0644);
```

1. **字符串（指针 vs 定长）**

```
static char *name = "eth0";                    // 指针
module_param(name, charp, 0644);

static char ifname[16] = "eth0";               // 定长数组
module_param_string(ifname, ifname, sizeof(ifname), 0644);
```

1. **自定义解析（合法性检查、复合结构）**

```
static int ratio;
static int ratio_set(const char *val, const struct kernel_param *kp)
{
    int v; if (kstrtoint(val, 10, &v) || v < 0 || v > 100) return -EINVAL;
    *(int *)kp->arg = v; return 0;
}
static int ratio_get(char *buf, const struct kernel_param *kp)
{ return scnprintf(buf, PAGE_SIZE, "%d\n", *(int *)kp->arg); }
static const struct kernel_param_ops ratio_ops = { .set = ratio_set, .get = ratio_get };
module_param_cb(ratio, &ratio_ops, &ratio, 0644);
```

------

# 七、排错与技巧

- **`modinfo foo.ko`**：查看参数与 `MODULE_PARM_DESC` 描述、类型。
- **`/sys/module/<mod>/parameters/\*`**：在线查看/修改（若权限允许）。
- **内置驱动参数不生效**：检查 **命令行是否带了模块名前缀**：`<mod>.<param>=...`。
- **字符串指针 `charp` 的生命周期**：内核会把用户传入值复制到专用区域，避免悬挂指针；但你自己分配/引用时仍需注意。
- **权限无效**：确保使用八进制（如 `0644`），并检查系统是否启用了限制（SELinux、只读 sysfs）。
- **数组个数统计**：`nump` 可为 NULL；若需要知道用户真正设置了多少元素，就传入 `&nset`。

------

# 八、对比一览（该用哪个？）

| 需求                        | 推荐宏                                            |
| --------------------------- | ------------------------------------------------- |
| 简单标量（int/bool/…）      | `module_param`                                    |
| 需要自定义对外名字          | `module_param_named`                              |
| 列表/数组                   | `module_param_array` / `module_param_array_named` |
| 定长字符串缓冲              | `module_param_string`                             |
| 复杂解析/校验/结构体        | `module_param_cb`                                 |
| 全局无前缀（内核/子系统级） | `core_param`（慎用）                              |
| 增加说明文本                | `MODULE_PARM_DESC`                                |



## 示例

```
drivers/hello_params/
├── Kconfig
├── Makefile
└── hello_params.c
```



## Kconfig

```
# drivers/char/hello_params/Kconfig
# SPDX-License-Identifier: GPL-2.0

menu "Hello Params Demo"

config HELLO_PARAMS
    tristate "Hello params driver (full parameter demo)"
    default M
    help
      A demo driver that showcases common module parameter macros:
      - module_param / _named / _array / _array_named / _string / _cb
      - MODULE_PARM_DESC
      - (plus one core_param example for built-in kernels)

endmenu

```

## Makefile

```
obj-$(CONFIG_HELLO_PARAMS) += hello_params.o
```

## hello_params.c

```c

// SPDX-License-Identifier: GPL-2.0
#include <linux/init.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/string.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("You");
MODULE_DESCRIPTION("Hello params driver - full parameter macros demo");
MODULE_VERSION("1.1");

/*
 * 1) 基本标量参数：module_param
 */
static bool enable = true;
module_param(enable, bool, 0644);
MODULE_PARM_DESC(enable, "Enable driver behavior (bool)");

static int level = 3;
module_param(level, int, 0644);
MODULE_PARM_DESC(level, "Log level (int)");

/*
 * 2) 重命名：module_param_named
 *    对外暴露 debug=...，但内部变量叫 level2
 */
static int level2 = 5;
module_param_named(debug, level2, int, 0644);
MODULE_PARM_DESC(debug, "Alias for internal 'level2' (int)");

/*
 * 3) 数组：module_param_array
 */
static int gains[8] = {0};
static int gains_set; /* 实际设置的个数 */
module_param_array(gains, int, &gains_set, 0644);
MODULE_PARM_DESC(gains, "Gain array (int list, e.g., gains=1,2,3)");

/*
 * 4) 数组 + 外部名字：module_param_array_named
 */
static unsigned int channels[8] = {0};
static int channels_set;
module_param_array_named(channel, channels, uint, &channels_set, 0644);
MODULE_PARM_DESC(channel, "Channel list (uint list, channel=1,6,11)");

/*
 * 5) 字符串参数两种方式：
 *    - charp：指针（内核会复制用户字符串）
 *    - module_param_string：定长缓冲区
 */
static char *namep = (char *)"world";
module_param(namep, charp, 0644);
MODULE_PARM_DESC(namep, "Name (charp)");

static char devname[16] = "hello0";
module_param_string(devname, devname, sizeof(devname), 0644);
MODULE_PARM_DESC(devname, "Device name (fixed buffer, 16B)");

/*
 * 6) 自定义解析/校验：module_param_cb
 *    ratio：0..100 之间，非法则 -EINVAL
 */
static int ratio = 50;

static int ratio_set(const char *val, const struct kernel_param *kp)
{
	int v, ret;

	ret = kstrtoint(val, 0, &v);
	if (ret)
		return ret;
	if (v < 0 || v > 100)
		return -EINVAL;

	*(int *)kp->arg = v;
	return 0;
}

static int ratio_get(char *buf, const struct kernel_param *kp)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n", *(int *)kp->arg);
}

static const struct kernel_param_ops ratio_ops = {
	.set = ratio_set,
	.get = ratio_get,
};

module_param_cb(ratio, &ratio_ops, &ratio, 0644);
MODULE_PARM_DESC(ratio, "Percentage 0..100 (validated via param_cb)");

/*
 * 7) 核心参数：
 *    - 内置进内核 (=y) 时：使用 core_param（无模块名前缀，bootargs 直接 hellocore=...）
 *    - 作为模块 (=m) 时：使用 module_param_named（insmod 时 hellocore=...）
 */
static int hellocore = 0;
#ifdef MODULE
module_param_named(hellocore, hellocore, int, 0644);
MODULE_PARM_DESC(hellocore, "core-like param when built as module");
#else
/* 注意：你这棵内核树的 core_param 为 3 个参数版本 */
core_param(hellocore, hellocore, int);
#endif

/* 打印帮助的小函数 */
static void print_array(const char *tag, const int *arr, int n)
{
	int i;
	pr_info("%s[%d]:", tag, n);
	for (i = 0; i < n; i++)
		pr_cont(" %d", arr[i]);
	pr_cont("\n");
}

static int __init hello_params_init(void)
{
	int i, n_g = gains_set, n_c = channels_set;

	/* 如果用户未设置数组元素，n_set 可能为 0；用默认长度展示 */
	if (!n_g)
		n_g = ARRAY_SIZE(gains);
	if (!n_c)
		n_c = ARRAY_SIZE(channels);

	pr_info("hello_params: init\n");
	pr_info(" enable=%d level=%d debug(level2)=%d namep=\"%s\" devname=\"%s\" ratio=%d hellocore=%d\n",
		enable, level, level2, namep, devname, ratio, hellocore);

	print_array(" gains", gains, n_g);
	/* 为了打印 unsigned int 数组，转换一下 */
	{
		int tmp[ARRAY_SIZE(channels)];
		for (i = 0; i < n_c; i++)
			tmp[i] = (int)channels[i];
		print_array(" channel", tmp, n_c);
	}

	pr_info("hello_params: loaded.\n");
	return 0;
}

static void __exit hello_params_exit(void)
{
	pr_info("hello_params: exit\n");
}

module_init(hello_params_init);
module_exit(hello_params_exit);

```



## 使用方法

### A) 作为模块（`=m`）

1. 配置并编译

- `make menuconfig` 里选：`Device Drivers → Hello Params Demo → M`
- 编译后会得到 `hello_params.ko`

1. **加载时传参：**

```
sudo insmod hello_params.ko \
  enable=1 level=7 debug=9 \
  gains=1,2,3 channel=6,11 \
  namep="linux" devname=eth0 \
  ratio=42
```

### B) 编进内核（`=y`）

- `make menuconfig` 里选 `<*>`

- **通过 bootargs 传参（注意“模块名前缀”）：**

  ```
  hello_params.enable=1 hello_params.level=7 hello_params.debug=9 \
  hello_params.gains=1,2,3 hello_params.channel=6,11 \
  hello_params.namep=linux hello_params.devname=eth0 \
  hello_params.ratio=60
  ```

- **core_param 无需前缀**（可选）：

  ```
  hellocore=1
  ```

- 启动后验证：

  ```
  dmesg | grep -i hello_params
  ```

------

## 常见坑

- **内置驱动的参数**要带前缀：`hello_params.param=...`；而 `core_param` 不带前缀。
- `perm` 用八进制（如 `0644`）；`0` 表示不导出到 sysfs。
- `module_param_array` 的元素个数通过第三个参数返回；未设置时可能为 `0`，可用 `ARRAY_SIZE()` 显示默认数组。
- `module_param_string` 用定长数组，避免指针生命周期问题；`charp` 更灵活，但注意长度与安全。

