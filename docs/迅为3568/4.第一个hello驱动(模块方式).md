# 编写第一个hello驱动(编译成模块)

直接拿模板，不必关注如何编写的，这一节只需要理解编译的过程

# helloworld.c

```c
#include <linux/module.h>
#include <linux/kernel.h> 
static int __init helloworld_init(void)        
{
	printk(KERN_EMERG "helloworld_init\r\n");
	return 0;
}
static void __exit helloworld_exit(void)    
{
	printk(KERN_EMERG "helloworld_exit\r\n");
}

module_init(helloworld_init);    
module_exit(helloworld_exit);   
MODULE_LICENSE("GPL v2");    
MODULE_AUTHOR("topeet"); 

```



## 编译工具链确认

在sdk中查看编译工具链（编译内核与单独的驱动最好保证使用同一个编译工具链）

```
ubuntu@ubuntu1804:~/rk3568/linux_sdk$ cd prebuilts
ubuntu@ubuntu1804:~/rk3568/linux_sdk/prebuilts$ ls
gcc
ubuntu@ubuntu1804:~/rk3568/linux_sdk/prebuilts$ find . -type f -name "aarch64*-gcc"
./gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc

```

编写 Makefile

-  将编译工具链的路径写入 Makefile当中 （若此处kernle的顶层Makefile文件有指定ARCH 和 CROSS_COMPILE，则此处的Makefile 可以不用指定）
- 指定内核路径

```makefile
#!/bin/bash
obj-m := helloworld.o

KDIR := /home/ubuntu/rk3568/linux_sdk/kernel
PWD  := $(shell pwd)

# 指定工具链和架构
ARCH := arm64
CROSS_COMPILE := /home/ubuntu/rk3568/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-

all:
	$(MAKE) -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

```

## 编译

```shell
ubuntu@ubuntu1804:~/rk3568/driver/01_helloworld$ make
make -C /home/ubuntu/rk3568/linux_sdk/kernel M=/home/ubuntu/rk3568/driver/01_helloworld ARCH=arm64 CROSS_COMPILE=/home/ubuntu/rk3568/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu- modules
make[1]: Entering directory '/home/ubuntu/rk3568/linux_sdk/kernel'
  CC [M]  /home/ubuntu/rk3568/driver/01_helloworld/helloworld.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /home/ubuntu/rk3568/driver/01_helloworld/helloworld.mod.o
  LD [M]  /home/ubuntu/rk3568/driver/01_helloworld/helloworld.ko
make[1]: Leaving directory '/home/ubuntu/rk3568/linux_sdk/kernel'
ubuntu@ubuntu1804:~/rk3568/driver/01_helloworld$ ls
helloworld.c  helloworld.ko  helloworld.mod.c  helloworld.mod.o  helloworld.o  Makefile  modules.order  Module.symvers

```



## 编译文件解析

下面是这些生成文件各自的含义与用途（按最常见关心度排序）：

### 快速对照表

| 文件                                   | 作用                                                         | 何时会用到                                        |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| `helloworld.ko`                        | **内核模块成品**（可装载的内核对象）                         | `insmod`/`modprobe` 加载到内核                    |
| `helloworld.o`                         | 源文件编译后的 **目标文件**（未链接成模块）                  | 中间产物，供 `modpost`/链接使用                   |
| `helloworld.mod.c`                     | Kbuild 自动生成的 **模块元数据源码**（包含 `MODULE_INFO` 信息） | 参与编译成 `.mod.o`，最终进入 `.ko`               |
| `helloworld.mod.o`                     | 由 `helloworld.mod.c` 编译得到的目标文件                     | 链接进 `.ko`，提供 vermagic、依赖、license 等信息 |
| `Module.symvers`                       | **符号版本表**：导出符号与其 CRC（启用 `CONFIG_MODVERSIONS` 时） | 供其他模块联编/二进制兼容校验使用                 |
| `modules.order`                        | 当前目录下 **模块编译顺序** 列表                             | 安装/打包模块时保持顺序                           |
| `.tmp_versions/`（未列出时可能已清理） | 保存每个模块的 **版本信息**（`*.mod`）                       | `modpost` 使用                                    |
| `*.cmd`（未列出时可能已清理）          | kbuild 的 **重建规则缓存**                                   | 用于增量构建判断是否需要重编                      |

