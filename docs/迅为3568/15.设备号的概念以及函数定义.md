# linux设备号的概念

在 Linux 内核中，**设备号（Device Number）**用来唯一标识一个设备文件（如 `/dev/sda`、`/dev/ttyS0`），让内核知道用户空间操作的是哪个设备驱动。
 设备号由 **主设备号（major number）** 和 **次设备号（minor number）** 两部分组成。

主设备号一般表示某一类设备，次设备号定义某一类设备的某个具体设备

## **1. 设备号的结构**

设备号类型是 `dev_t`，定义在 **`include/linux/types.h`**：

```
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
```

设备号是一个整型值，内部按位存储：

- **主设备号（major number）**：标识设备所属的驱动程序。
- **次设备号（minor number）**：标识同一个驱动下的不同设备实例。

常见的组合宏定义在 **`include/linux/kdev_t.h`**：

- 设备号  默认是 32 位无符号整数 （在某些 64 位架构或特殊内核配置中，`dev_t` 也可能扩展到 **64 位**）
- 高12位表示主设备号（0 ~ 4095），低20位表示此次设备号（0 ~ 1,048,575）

```
dev_t (32 位)
+----------------+----------------------+
| 主设备号 (12b) | 次设备号 (20b)       |
+----------------+----------------------+
bit31.........bit20 bit19.............bit0

```

```
#define MINORBITS   20
#define MINORMASK   ((1U << MINORBITS) - 1)

#define MAJOR(dev)  ((unsigned int) ((dev) >> MINORBITS))
#define MINOR(dev)  ((unsigned int) ((dev) & MINORMASK))
#define MKDEV(ma,mi)    (((ma) << MINORBITS) | (mi))
```

------

## **2. 静态设备号**

静态设备号是**手动分配并固定**的设备号，通常适用于固定功能的驱动或内核内置驱动。

### **分配方式**

使用 `register_chrdev_region()` 或 `register_blkdev()` 等 API 注册：

```
int register_chrdev_region(dev_t from, unsigned count, const char *name);
```

- **from**：通过 `MKDEV(major, minor)` 生成的起始设备号
- **count**：连续申请的设备号数量
- **name**：设备名字，供 `/proc/devices` 使用

示例：

```
dev_t dev_num;
int major = 240;   // 自定义主设备号
int minor = 0;
dev_num = MKDEV(major, minor);

if (register_chrdev_region(dev_num, 1, "my_device") < 0) {
    pr_err("failed to register static dev num\n");
}
```

这种方式要求 **major 号在系统中没有被占用**。

------

## **3. 动态设备号**

动态设备号由内核**自动分配**，避免了手动分配冲突。

### **分配方式**

使用 `alloc_chrdev_region()`：

```
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);
```

- **dev**：输出参数，返回分配到的设备号
- **baseminor**：起始次设备号
- **count**：数量
- **name**：设备名

示例：

```
dev_t dev_num;

if (alloc_chrdev_region(&dev_num, 0, 1, "my_device") < 0) {
    pr_err("failed to allocate dev num\n");
} else {
    pr_info("allocated major=%d, minor=%d\n", MAJOR(dev_num), MINOR(dev_num));
}
```

------

## **4. 注销设备号**

无论是静态还是动态分配，卸载模块时都应释放：

```
void unregister_chrdev_region(dev_t from, unsigned count);
```

示例：

```
unregister_chrdev_region(dev_num, 1);
```

------

## **5. 查看设备号**

### **(1) 查看内核注册的主设备号**

```
cat /proc/devices
```

输出示例：

```
Character devices:
  1 mem
  5 /dev/tty
 10 misc
240 my_device
```

### **(2) 查看具体设备文件的设备号**

```
ls -l /dev/ttyS0
```

输出示例：

```
crw-rw---- 1 root dialout 4, 64 Aug 21 10:00 /dev/ttyS0
```

- `c`：字符设备
- `4, 64`：主设备号 = 4，次设备号 = 64

------

## **6. 常用函数列表**

| 函数                         | 用途                 |
| ---------------------------- | -------------------- |
| `MKDEV(major, minor)`        | 生成 `dev_t` 设备号  |
| `MAJOR(dev_t)`               | 获取主设备号         |
| `MINOR(dev_t)`               | 获取次设备号         |
| `register_chrdev_region()`   | 静态分配设备号       |
| `alloc_chrdev_region()`      | 动态分配设备号       |
| `unregister_chrdev_region()` | 释放设备号           |
| `cdev_init()`                | 初始化 `cdev` 结构体 |
| `cdev_add()`                 | 将 `cdev` 加入内核   |
| `cdev_del()`                 | 删除 `cdev`          |

------

## **7. 静态与动态设备号对比**

| 特性        | 静态分配           | 动态分配               |
| ----------- | ------------------ | ---------------------- |
| 主设备号    | 固定，需要手动指定 | 由内核自动分配         |
| 冲突风险    | 高，需要手动管理   | 无冲突，内核管理       |
| 调试/兼容性 | 方便老版本程序访问 | 程序需动态获取主设备号 |
| 常用场景    | 驱动长期固定开发   | 临时驱动、实验性驱动   |



## 现代开发常用的是静态设备号还是动态设备号？

在现代 Linux 驱动开发中，**更多情况下使用的是动态设备号**，静态设备号已经很少直接手动指定了，除非有特殊需求。

下面从实际开发角度比较一下两者的常见使用场景和选择依据。

------

## **1. 常用情况**

| 场景                         | 推荐方式       | 原因                                                         |
| ---------------------------- | -------------- | ------------------------------------------------------------ |
| **自研驱动/实验驱动**        | **动态设备号** | 无需关心冲突，内核自动分配，开发调试方便                     |
| **临时调试**                 | **动态设备号** | 每次加载都可以获取安全的设备号                               |
| **商用驱动 / 固定 API 驱动** | **静态设备号** | 为了和用户空间工具兼容（例如 `/dev/ttyS0` 永远是主设备号 4） |
| **内核内置驱动**             | **静态设备号** | 厂商和内核维护固定号，方便长期维护和一致性                   |

------

## **2. 为什么动态分配更常见**

1. **避免冲突**
    静态主设备号有 4096 个编号，但很多编号都已被内核占用，人工选择容易冲突。
    动态分配由内核自动分配，不存在冲突问题。

2. **可扩展性**
    动态方式可一次分配多个连续次设备号，方便一个驱动管理多个实例。

3. **便于调试**
    调试阶段可以不关心具体编号，直接让系统分配并打印出来：

   ```
   alloc_chrdev_region(&dev_num, 0, 1, "my_device");
   pr_info("major=%d minor=%d\n", MAJOR(dev_num), MINOR(dev_num));
   ```

4. **与 udev 配合方便**
    现代 Linux 都使用 `udev` 自动创建设备节点，即使主设备号变动，也能通过规则文件保持 `/dev` 下节点名称一致。

------

## **3. 静态设备号仍有意义的情况**

- **标准字符/块设备**：
  - 如 `tty`、`null`、`sda` 等主设备号固定，方便用户空间直接使用。
- **厂商指定兼容性**：
  - 某些历史项目或协议依赖特定设备号。
- **调试硬件接口**：
  - 方便通过固定 `mknod` 创建设备节点。

------

## **4. 总结建议**

| 开发阶段          | 推荐设备号分配方式                        | 备注                                   |
| ----------------- | ----------------------------------------- | -------------------------------------- |
| 个人学习/驱动调试 | **动态设备号 (`alloc_chrdev_region`)**    | 自动避免冲突                           |
| 产品化/内核合入   | **动态设备号 + udev 固定名称**            | 通过规则保证稳定路径，而不是固定主次号 |
| 特殊兼容需求      | **静态设备号 (`register_chrdev_region`)** | 确保主设备号不变                       |



## **5. 现代做法示例**

一般推荐：

1. **内核动态分配设备号**
2. **udev 固定名字**，而不是固定号

示例 udev 规则：

```
# /etc/udev/rules.d/99-mydev.rules
KERNEL=="my_device*", NAME="my_device%n"
```

无论设备号是多少，用户空间访问 `/dev/my_device0` 都是稳定的。

------

**总结**

> **大多数驱动开发**都会使用**动态设备号**，再用 `udev` 或 `mdev` 保持 `/dev` 下的设备节点名字一致；**静态设备号**更多见于历史驱动、内核内置驱动或者需要兼容旧版本的场景。







