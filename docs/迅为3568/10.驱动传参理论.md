Linux 驱动要和应用/内核其他部分交互，常常需要 **传递参数**。

参数传递有几种典型形式，按 **内核启动 → 驱动加载 → 运行时交互** 来分类给梳理：

# 🚦1. 内核启动参数传递 (bootargs → 驱动)

驱动可以通过 **内核命令行参数** 接收配置。

- **机制**：在驱动里用 `module_param()` 或 `__setup()`。

### 示例：`module_param`

```
static int debug = 0;
module_param(debug, int, 0644);
MODULE_PARM_DESC(debug, "Enable debug prints");

static int __init hello_init(void)
{
    if (debug)
        pr_info("Debug mode on\n");
    return 0;
}
```

使用：

```
bootargs: hello.debug=1
```

------

# 🚦 2. 模块加载参数传递 (`insmod xxx.ko param=...`)

当驱动是 **模块 (`=m`)** 时，可以直接给 `.ko` 传参。

- **定义**：同样用 `module_param()` / `module_param_array()`。

- **方式**：

  ```
  insmod hello.ko debug=1 name="test"
  ```

- **效果**：内核调用 `hello_init()` 时，参数已生效。

------

# 🚦 3. 设备树 (Device Tree, DT) 参数

嵌入式/SoC 上最常见。驱动通过 **设备树节点** 获取参数。

### 示例

```
hello@0 {
    compatible = "myvendor,hello";
    reg = <0x1000 0x100>;
    debug-level = <2>;
    name = "dev-hello";
};
```

### 驱动里解析

```
static int hello_probe(struct platform_device *pdev)
{
    struct device_node *np = pdev->dev.of_node;
    u32 dbg;
    const char *name;

    of_property_read_u32(np, "debug-level", &dbg);
    of_property_read_string(np, "name", &name);

    pr_info("debug=%u name=%s\n", dbg, name);
    return 0;
}
```

------

# 🚦 4. 内核 API / Sysfs / Procfs

驱动运行后，可以通过 **文件系统接口** 让用户态传参。

### sysfs 属性

```
static ssize_t hello_show(struct device *dev,
                          struct device_attribute *attr, char *buf)
{
    return sprintf(buf, "%d\n", debug);
}

static ssize_t hello_store(struct device *dev,
                           struct device_attribute *attr,
                           const char *buf, size_t count)
{
    sscanf(buf, "%d", &debug);
    return count;
}
static DEVICE_ATTR_RW(hello);
```

用户态：

```
echo 1 > /sys/devices/platform/hello/hello
cat /sys/devices/platform/hello/hello
```

### procfs / debugfs

一些驱动会暴露 `/proc/driver/hello` 或 `/sys/kernel/debug/hello` 来交互。

------

# 🚦 5. IOCTL / 用户空间调用

驱动提供 **字符设备节点**，通过 `ioctl()` 与应用程序交互，传递复杂参数。

驱动：

```
#define HELLO_SET_PARAM  _IOW('h', 1, int)
static long hello_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
    int val;
    switch(cmd) {
    case HELLO_SET_PARAM:
        if (copy_from_user(&val, (int __user *)arg, sizeof(val)))
            return -EFAULT;
        debug = val;
        return 0;
    }
    return -ENOTTY;
}
```

应用：

```
int val = 5;
ioctl(fd, HELLO_SET_PARAM, &val);
```

# 📌 总结：Linux 驱动传参常见方式

| 方式                     | 适用场景          | 特点                         |
| ------------------------ | ----------------- | ---------------------------- |
| **module_param**         | 内核启动 / insmod | 适合简单布尔/数值/字符串参数 |
| **设备树 (DT)**          | 嵌入式/SoC        | 主流，硬件相关参数描述       |
| **sysfs/procfs/debugfs** | 运行时修改        | 参数可动态调整               |
| **ioctl**                | 用户程序交互      | 复杂指令/结构体传递          |
| **平台数据**             | 老式板级文件      | 现在已少用                   |

✅ 一句话总结：

- **编译/启动时**：`bootargs`、`module_param`
- **硬件描述**：设备树 (DT)
- **运行时动态修改**：sysfs/procfs/debugfs/ioctl