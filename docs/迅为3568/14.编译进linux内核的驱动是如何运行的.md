## 1. 驱动代码的入口与注册

一个标准 Linux 驱动（无论内置还是模块），都会写：

```
static int __init hello_init(void)
{
    pr_info("Hello, world driver loaded!\n");
    // 注册字符设备 / 平台驱动 / 总线驱动 / file_ops...
    return 0;
}

static void __exit hello_exit(void)
{
    pr_info("Hello, world driver unloaded!\n");
    // 注销资源
}

module_init(hello_init);
module_exit(hello_exit);
```

区别在于：

- **模块 (`=m`)**：`insmod` 时内核调用 `hello_init()`，`rmmod` 时调用 `hello_exit()`。
- **内置 (`=y`)**：在内核启动流程中，内核会在合适的时机自动调用 `hello_init()`。

------

## 2. 内核是如何调用 `hello_init()` 的？

当你 `CONFIG_HELLOWORLD=y` 时：

1. **编译阶段**

   - 你的 `.c` 文件会被编进 `built-in.o` → 链接进 `vmlinux`。

   - `module_init()` 宏会把 `hello_init` 放到一个特殊的 **`.initcall` 段**。

     > 内核有很多 initcall level，比如 `core_initcall`、`subsys_initcall`、`fs_initcall`，控制不同子系统的初始化顺序。

   - 链接器脚本 (`vmlinux.lds`) 会把这些 initcall 排好序。

2. **启动阶段**

   - 当 Linux 内核启动时，会依次执行这些 `.initcall` 段的函数。

   - 到达你的驱动所在阶段时，`hello_init()` 被调用 → 设备注册完成。

   - 于是你在 `dmesg` 里看到：

     ```
     Hello, world driver loaded!
     ```

------

## 3. 驱动运行后做了什么？

这取决于你的驱动类型：

- **字符设备驱动**
  - 在 `hello_init()` 里调用 `register_chrdev()`
  - 内核在 `/dev/` 下生成节点（或需要 `mknod`）
  - 用户空间就可以 `open("/dev/hello")`
- **平台驱动 / 总线驱动**
  - 内核根据 `platform_device` / `of_match_table` / `acpi_id_table` 自动匹配
  - 匹配成功 → 调用你的 `probe()` 函数，开始驱动硬件
- **文件系统 / 网络协议栈驱动**
  - 通过 `register_filesystem()` 或 `register_netdev()` 注册到内核子系统
  - 被使用时触发你的回调函数（比如挂载文件系统 / 打开网卡接口）

------

## 4. 驱动卸载

- **内置 (`=y`)** → 驱动不可卸载，`hello_exit()` 不会被执行。
- **模块 (`=m`)** → `rmmod` 时会执行 `hello_exit()`，释放资源。

------

## 5. 总结一句话

- 驱动编译进内核镜像后，并不是“静态代码”，而是通过 **`module_init()` → `.initcall` 机制** 在内核启动时自动运行的。
- 内核在启动过程中调用 `hello_init()`，驱动就完成了 **注册 → 匹配 → 提供接口**，最终被用户空间或其他子系统使用。





##  **Linux 内核中内置驱动运行的时序图**，展示从 **内核启动** 到 **驱动生效** 的关键路径

```
+-------------------+
| Bootloader (U-Boot|
| or others)        |
+---------+---------+
          |
          v
+-------------------+
| Kernel Entry (arch/xxx)       |
| - 解压 zImage / Image         |
| - 跳转到 start_kernel()       |
+-------------------+
          |
          v
+-------------------+
| start_kernel()                     |
| - 设置内存管理、调度器             |
| - 初始化基础硬件 (CPU, MMU, IRQ)   |
+-------------------+
          |
          v
+-------------------+
| rest_init()                          |
| - 启动 kernel_init() (PID 1)         |
| - 开始执行 initcall 链表             |
+-------------------+
          |
          v
+-------------------+
| do_initcalls()                     |
| - 遍历各级 initcall 段              |
|   (early_initcall, core_initcall,   |
|    subsys_initcall, fs_initcall...) |
| - 执行所有注册的 init 函数          |
+-------------------+
          |
          v
+-------------------+
| hello_init() (来自驱动)       |
| - printk("Hello...")                |
| - 注册字符设备 / 平台驱动           |
| - 可能挂接 /dev 节点                |
+-------------------+
          |
          v
+-------------------+
| 驱动完成注册 → 设备可用            |
| - 若匹配 platform_device → 调用 probe() |
| - 若字符设备 → 可 open("/dev/hello")   |
+-------------------+
          |
          v
+-------------------+
| 用户空间应用层                    |
| - 使用 open/ioctl/read/write       |
| - 访问驱动提供的接口               |
+------------------------------------+

```

**bootloader** → 负责把内核镜像加载到内存并启动。

**start_kernel()** → 内核的 C 入口，初始化各种核心子系统。

**do_initcalls()** → 逐级调用 `.initcall` 段里的函数（这就是 `module_init()` 注册的地方）。

**hello_init()** → 你的驱动初始化函数被执行，注册进内核。

**probe()**（若有匹配设备树 / 总线） → 驱动真正绑定设备，开始工作。

**用户应用** → 通过 `/dev` 节点或系统调用访问驱动。