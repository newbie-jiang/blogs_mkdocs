# linux 动态设备号实操

- 使用动态设备号，再用 `udev` 或 `mdev` 保持 `/dev` 下的设备节点名字一致



## mychardev.c

```c
// SPDX-License-Identifier: GPL-2.0
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>

#define DRV_NAME "mychardev"
#define BUF_SZ   4096

static dev_t devno;               // 动态分配得到的 dev_t
static struct cdev my_cdev;       // 字符设备对象
static struct class *my_class;    // /sys/class/<name>
static char kbuf[BUF_SZ];
static size_t klen;

static int my_open(struct inode *inode, struct file *filp)
{
    pr_info(DRV_NAME ": open (major=%d minor=%d)\n",
            imajor(inode), iminor(inode));
    return 0;
}

static int my_release(struct inode *inode, struct file *filp)
{
    pr_info(DRV_NAME ": release\n");
    return 0;
}

static ssize_t my_read(struct file *filp, char __user *ubuf,
                       size_t len, loff_t *off)
{
    size_t to_copy;

    if (*off >= klen)
        return 0;

    to_copy = min(len, klen - *off);
    if (copy_to_user(ubuf, kbuf + *off, to_copy))
        return -EFAULT;

    *off += to_copy;
    return to_copy;
}

static ssize_t my_write(struct file *filp, const char __user *ubuf,
                        size_t len, loff_t *off)
{
    size_t to_copy = min(len, (size_t)BUF_SZ);

    if (copy_from_user(kbuf, ubuf, to_copy))
        return -EFAULT;

    klen = to_copy;
    pr_info(DRV_NAME ": write %zu bytes\n", to_copy);
    return to_copy;
}

static const struct file_operations fops = {
    .owner   = THIS_MODULE,
    .open    = my_open,
    .release = my_release,
    .read    = my_read,
    .write   = my_write,
    .llseek  = no_llseek,
};

static int __init my_init(void)
{
    int ret;

    // 1) 动态分配一个主/次设备号（只要 1 个次设备）
    ret = alloc_chrdev_region(&devno, 0, 1, DRV_NAME);
    if (ret) {
        pr_err(DRV_NAME ": alloc_chrdev_region failed: %d\n", ret);
        return ret;
    }

    // 2) 初始化并注册 cdev
    cdev_init(&my_cdev, &fops);
    my_cdev.owner = THIS_MODULE;

    ret = cdev_add(&my_cdev, devno, 1);
    if (ret) {
        pr_err(DRV_NAME ": cdev_add failed: %d\n", ret);
        unregister_chrdev_region(devno, 1);
        return ret;
    }

    // 3) 创建 class（供 udev 识别/创建设备节点）
    my_class = class_create(THIS_MODULE, DRV_NAME);
    if (IS_ERR(my_class)) {
        ret = PTR_ERR(my_class);
        pr_err(DRV_NAME ": class_create failed: %d\n", ret);
        cdev_del(&my_cdev);
        unregister_chrdev_region(devno, 1);
        return ret;
    }

    // 4) 创建设备节点：/dev/mychardev0
    if (IS_ERR(device_create(my_class, NULL, devno, NULL, DRV_NAME "%d", 0))) {
        pr_err(DRV_NAME ": device_create failed\n");
        class_destroy(my_class);
        cdev_del(&my_cdev);
        unregister_chrdev_region(devno, 1);
        return -EINVAL;
    }

    pr_info(DRV_NAME ": loaded. major=%d minor=%d node=/dev/%s0\n",
            MAJOR(devno), MINOR(devno), DRV_NAME);
    return 0;
}

static void __exit my_exit(void)
{
    device_destroy(my_class, devno);
    class_destroy(my_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(devno, 1);
    pr_info(DRV_NAME ": unloaded\n");
}

module_init(my_init);
module_exit(my_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("You");
MODULE_DESCRIPTION("Dynamic dev_t + udev stable path demo");

```



## Makefile

```
#!/bin/bash
obj-m := mychardev.o

KDIR := /home/ubuntu/rk3568/linux_sdk/kernel
PWD  := $(shell pwd)

# 指定工具链和架构
ARCH := arm64
CROSS_COMPILE := /home/ubuntu/rk3568/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-

all:
	$(MAKE) -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```



## 99-mychardev.rules

```
KERNEL=="mychardev[0-9]*", SYMLINK+="mydev%n", MODE="0666", GROUP="plugdev"
RULE
```

编译

```
make
```

传输

```
scp chardev.ko 99-mychardev.rules root@192.168.0.104:/tmp/
```

将99-mychardev.rules放到/etc/udev/rules.d目录

```
cp 99-mychardev.rules /etc/udev/rules.d
```

## 加载模块 

```
insmod mychardev.ko 
```

- 可以看到已经自动分配了设备号，包括 主设备号major=236  次设备号minor=0  分配节点 node=/dev/mychardev0

```
[root@topeet:/tmp]# insmod mychardev.ko 
[  165.909031] mychardev: loading out-of-tree module taints kernel.
[root@topeet:/tmp]# [  165.910416] mychardev: loaded. major=236 minor=0 node=/dev/mychardev0

```

## 验证内核是否创建节点

```
[root@topeet:/tmp]# ls -l /dev/mychardev*
```

```
[root@topeet:/tmp]# ls -l /dev/mychardev*
crw-rw-rw- 1 root plugdev 236, 0 Aug 21 15:04 /dev/mychardev0

```

## 应用 udev 规则并触发

确保这个文件存在

```
[root@topeet:/etc/udev/rules.d]# ls
99-mychardev.rules
[root@topeet:/etc/udev/rules.d]# cat 99-mychardev.rules 
KERNEL=="mychardev[0-9]*", SYMLINK+="mydev%n", MODE="0666", GROUP="plugdev"
RULE
```

重新加载并触发：

```
 udevadm control --reload
 udevadm trigger --name-match="/dev/mychardev0"
 # 或者直接重新插/卸载模块：
 rmmod mychardev &&  insmod mychardev.ko
```

## 验证

```
[root@topeet:/tmp]#  ls -l /dev/mydev*
lrwxrwxrwx 1 root root 10 Aug 21 15:24 /dev/mydev0 -> mychardev0
```

