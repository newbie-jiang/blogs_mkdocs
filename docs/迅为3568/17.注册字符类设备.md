# 注册字符类设备

# 概念总览

- **字符设备**：按**字节流**与用户态交互（如串口、GPIO 控制接口等），对应 `/dev/*` 设备节点。
- **VFS 调度**：用户态的 `open/read/write/ioctl/poll/mmap/...` 通过 **VFS** 分发到驱动提供的一组回调（`file_operations`）。
- **设备号（dev_t）**：由 **主设备号 major** + **次设备号 minor** 组成，标识驱动类型与具体实例。
- **节点创建**：现代系统通常通过 `class`/`device` + **udev** 自动生成 `/dev/xxx`；也可手工 `mknod`（较少用了）。

# 两条主流注册路径

1. **标准 cdev 流程（最通用，可细粒度控制）**
   - 分配设备号 → 初始化/注册 `cdev` →（可选）建立 `class` 与 `device` 以触发 udev 创建设备节点。
   - 适合**多实例**、复杂 IO、需要自定义次设备布局的驱动。
2. **misc 设备（快速路径）**
   - 用 `misc_register()` 把设备挂到固定主设备号 10（misc）下，**内核分配次设备号**。
   - 适合**简单单实例**或不需要自己管理一段次设备号的场景；更省事，但灵活度稍低。

# 设备号：概念与用法

- **动态分配（推荐）**：让内核分配可用的主/次设备号，避免冲突。
  - `alloc_chrdev_region(dev*, baseminor, count, name)`
  - 关键参数：
    - `dev*`：输出得到的 `dev_t`
    - `baseminor`：起始次设备号（常用 0）
    - `count`：一次要多少个连续次设备号（多实例时 >1）
    - `name`：显示在 `/proc/devices` 的名称
- **静态注册**：你指定主设备号与起始次设备号，若占用会失败。
  - `register_chrdev_region(from_dev, count, name)`
- **释放**：卸载时配对 `unregister_chrdev_region(from_dev, count)`

> 位宽：主流配置下 dev_t 总 32 位（major 12、minor 20），但**以内核实际配置为准**；使用宏 `MAJOR(dev_t) / MINOR(dev_t) / MKDEV(major,minor)` 取用/构造。

# cdev 注册：概念与用法

- `cdev` 是把你的 **文件操作回调** 挂到 VFS 的对象。
- 常用函数：
  - `cdev_init(cdev*, file_operations*)`：初始化 cdev 并绑定回调表
  - `cdev_add(cdev*, dev_t first, count)`：注册到内核（可覆盖多次设备）
  - `cdev_del(cdev*)`：注销
- **一个 cdev 管多实例**：`count > 1`；回调中通过 **次设备号**区分实例（`iminor(inode)`）。
- **多个 cdev**：每实例一个 cdev，便于隔离与不同回调。

# /dev 节点的导出：概念与用法

- **现代做法**：建立 **class** 与 **device**，让 **udev** 自动创建设备节点并可加权限/别名。
  - `class_create(owner, "classname")` → 出现 `/sys/class/classname/`
  - `device_create(class, parent, devt, drvdata, "nodefmt", idx)` → 触发 udev 创建 `/dev/node`
  - 配对的销毁：`device_destroy()` → `class_destroy()`
- **udev 规则**（在板子的 rootfs 上）：
  - 典型：`KERNEL=="mychardev[0-9]*", SYMLINK+="mydev%n", MODE="0666", GROUP="plugdev"`
  - 作用：为真实节点 `/dev/mychardev0` 增加稳定别名 `/dev/mydev0`，并设置权限/组。
- **手工 mknod**：仅在没有 udev 的极简系统上作为备选。

# VFS→驱动：常用回调与参数解析

（回调都在 `struct file_operations` 里；以下给**调用时机、关键参数与常见返回值**）

- **`.open(inode\*, file\*)`**
  - *何时*：用户 `open()` 设备文件时
  - *用途*：准备会话上下文，可在 `file->private_data` 绑定实例数据
  - *返回*：0 成功，负值错误码（如 `-ENODEV/-EBUSY`）
- **`.release(inode\*, file\*)`**
  - *何时*：`close()` 或进程退出时
  - *用途*：释放会话资源、减少引用
  - *返回*：0 或错误码
- **`.read(file\*, __user \*buf, size_t count, loff_t \*ppos)`**
  - *何时*：用户 `read()`
  - *参数*：
    - `buf`：**用户态**指针（必须用 `copy_to_user()` 等访问）
    - `count`：希望读取的字节数
    - `ppos`：文件内偏移（可用于顺序读取）
  - *返回*：实际读取字节数；0 表 EOF；负值错误码（如 `-EFAULT/-EAGAIN/-ERESTARTSYS`）
- **`.write(file\*, const __user \*buf, size_t count, loff_t \*ppos)`**
  - *何时*：`write()`
  - *参数*：同上，往**内核**读入用户数据需 `copy_from_user()`
  - *返回*：已写入字节数或负值错误码
- **`.llseek(file\*, off_t, whence)`**
  - 控制 `*ppos` 的移动；若设备不支持定位，使用 `no_llseek`；若支持，常用 `default_llseek`
- **`.unlocked_ioctl(file\*, cmd, unsigned long arg)` 与 `.compat_ioctl`**
  - *何时*：`ioctl(fd, cmd, arg)`
  - *cmd 编码*：用 `_IO/_IOR/_IOW/_IOWR` 宏设计（包含方向、大小、魔数、序号）
  - *参数*：
    - `cmd`：操作码
    - `arg`：用户态指针或整数（64/32 兼容问题走 `compat_ioctl`）
  - *返回*：0 或负值；若返回结构到用户态，仍需 `copy_to_user()`
- **`.poll(file\*, poll_table \*wait)`**
  - *何时*：用户 `poll/epoll/select`
  - *用途*：报告当前可读/可写/错误等事件（返回 `POLLIN|POLLOUT|POLLERR...`），并把 `wait` 与你的等待队列绑定，实现**就绪通知**
  - *配套*：内核侧数据就绪时 `wake_up_interruptible(&wq)`
- **`.mmap(file\*, vm_area_struct \*vma)`**
  - *何时*：用户 `mmap()` 设备节点
  - *用途*：高性能共享缓冲; 复杂度较高，注意缓存一致性与 VM 操作
  - *返回*：0 或错误码
- **`.flush` / `.fsync` / `.fasync`**
  - 较少用：`flush` 在 `close()` 前；`fsync` 为落盘/同步；`fasync` 为异步通知（`SIGIO`）
- **`.owner = THIS_MODULE`**
  - 重要！VFS 在打开设备时增加模块引用，避免卸载中断正在使用的回调。

# 用户态交互要点

- **用户缓冲区**：只能用 `copy_to_user()/copy_from_user()` 或 `get_user()/put_user()` 访问；否则内核崩溃。
- **非阻塞 I/O**：文件以 `O_NONBLOCK` 打开时，不可立即满足的读/写应返回 `-EAGAIN`；阻塞情形使用等待队列并可被信号打断（返回 `-ERESTARTSYS`）。
- **ioctl 设计**：用统一魔数、编号与方向；驱动端可用 `_IOC_*` 宏解码并检查结构大小，避免 ABI 混乱。

# 多实例与次设备（minor）的用法

- 一次申请多个次设备（`count = N`），让**同一套回调**服务多个实例。
- 在回调中通过 **`iminor(inode)`** 或 **`MINOR(file->f_inode->i_rdev)`** 分辨实例。
- 可以为每个实例维护各自的缓冲、锁、状态机；或一个实例一个 `cdev`。

# 并发与生命周期

- **会话私有数据**：`file->private_data` 挂每次 `open()` 的上下文。
- **锁**：中断上下文用自旋锁；进程上下文用互斥量；引用计数用 `refcount_t/atomic_t`。
- **模块引用**：`.owner=THIS_MODULE` + 谨慎的热插拔/卸载路径，避免 use-after-free。

# 典型清理顺序（卸载时）

1. 停止对外服务（如禁止新 `open`、通知在途 I/O 结束）
2. `device_destroy` → `class_destroy`
3. `cdev_del`
4. `unregister_chrdev_region`

# 调试与自检

- `/proc/devices`：查看主设备号登记
- `/sys/class/<class>/`：class 与 device 是否创建
- `ls -l /dev/*`：节点是否存在、权限是否正确
- `udevadm info/monitor/test`：udev 是否应用规则、别名是否创建
- `dmesg`：驱动日志与错误路径

# 常见坑与经验

- **类型不匹配**：`min()/max()` 需保证两侧类型一致，推荐 `min_t(type, a, b)`。
- **偏移管理**：`read/write` 要维护 `*ppos` 与缓冲边界；不支持定位就用 `no_llseek`。
- **权限/组**：别在驱动里硬编码权限；交给 **udev 规则**统一管理更灵活。
- **阻塞/信号**：阻塞等待时检查 `signal_pending()`；返回 `-ERESTARTSYS` 让内核处理重启。
- **用户指针**：任何来自用户态的指针都必须当成“不可信”处理，先 `copy_from_user()` 到内核缓冲再用。
- **热插拔/并发关闭**：注意与 `rmmod`、电源管理回调（`suspend/resume`）的竞态。

# misc 设备的参数说明（快速回顾）

- `struct miscdevice`：
  - `minor`：`MISC_DYNAMIC_MINOR`（常用）、或固定次设备号
  - `name`：在 `/dev/` 下的节点名（通常就是它）
  - `fops`：回调表
  - `mode`：节点权限（简化了 udev 配置，但生产上仍建议配合 udev 做更细规则）
- 函数：`misc_register()` / `misc_deregister()`

------

**一句话记忆**：

> “**动态分配设备号** + **cdev 注册** + **class/device 导出** + **udev 规则固化名字与权限**，回调中用 **copy_to/from_user**、**poll 等同步机制** 与用户空间打通，这就是字符设备注册与访问的通用套路。”
