## 一、基础理解

**现代操作系统（包括Linux）采用虚拟内存管理**，为每个进程分配独立的虚拟地址空间。虚拟地址空间一般分为两部分：

- **用户空间（User Space）**：进程可以访问的区域。
- **内核空间（Kernel Space）**：只有操作系统内核能访问，用户程序不能直接访问。

------

## 二、32位Linux下的典型地址分配

在传统的**32位Linux**（如x86）系统中，虚拟地址空间为4GB（0x00000000 ~ 0xFFFFFFFF）：

| 区域     | 地址范围                | 说明                                    |
| -------- | ----------------------- | --------------------------------------- |
| 用户空间 | 0x00000000 ~ 0xBFFFFFFF | 3GB（大部分应用程序可用）               |
| 内核空间 | 0xC0000000 ~ 0xFFFFFFFF | 1GB（操作系统内核及其模块、驱动等使用） |



- 这样设计的好处是：用户空间和内核空间**完全隔离**，用户程序不能随便访问内核地址，提升了安全性。
- 当用户程序通过系统调用进入内核态时，内核会操作自己的空间，而不是用户的空间。

> 注意：内核空间地址在每个进程的虚拟空间都可见，但普通应用不能访问，试图访问会导致“段错误”（segfault）。

------

## 三、64位Linux下的地址分配

- 64位系统虚拟地址非常大（理想值可达16EB），实际只用到一部分。
- 用户空间和内核空间的分界线常常在高地址（如x86_64的0x00007FFFFFFFFFFF是用户空间最大地址）。
- 例如（x86_64，常见情况）：
  - 用户空间：`0x0000000000000000` ~ `0x00007FFFFFFFFFFF` （128TB）
  - 内核空间：`0xFFFF800000000000` ~ `0xFFFFFFFFFFFFFFFF` 等（具体取决于内核配置）
- 用户空间远大于32位，并且仍然严格隔离。

------

## 四、常见的几种地址空间分布图

### 32位 Linux

```
| 0xFFFFFFFF   |---------------------------|
|              |      内核空间（1GB）       |
| 0xC0000000   |---------------------------|
|              |      用户空间（3GB）       |
| 0x00000000   |---------------------------|
```

### 64位 Linux

```
| 0xFFFFFFFFFFFFFFFF |----------------------|
|                    |      内核空间        |
| 0x00007FFFFFFFFFFF |----------------------|
|                    |      用户空间        |
| 0x0000000000000000 |----------------------|
```

- **实际内核和用户空间的分割点可以通过内核配置参数更改。**

------

## 五、特殊情况说明

- 有的服务器为了性能或兼容，会做不同的分配（比如2G/2G分割）。
- ARM、MIPS等嵌入式架构下的分配方式也可能不同，但原理一样，都是**空间隔离**。

------

## 六、物理内存与虚拟内存

- 上述所有地址都是**虚拟地址**。
- **内核有权限将虚拟地址映射到物理地址**；用户空间的映射只在本进程有效。

------

## 七、总结一句话

> **用户空间和内核空间分别占用虚拟内存的不同区域，通过严格的地址隔离保障系统安全和稳定。常见32位系统3G/1G分割，64位系统用户空间极大。**