**NFS 挂载原理**
 开发板上运行的 Linux（比如嵌入式 ARM 平台）通常没有本地存储，或者是调试时不方便频繁更换镜像。这时常用的做法是：

- **内核（zImage、Image）**和**设备树（.dtb 文件）**通过 TFTP 方式从 Ubuntu 主机下载到开发板内存，然后启动。
- **根文件系统**通过 NFS 挂载，这样你在 Ubuntu 主机（开发机）上维护一个目录，开发板每次启动时都把这个目录作为根文件系统使用，方便开发、调试。



需要在 Ubuntu 上**共享一个文件夹**，比如 `/nfsroot`，用来作为根文件系统。开发板通过网络挂载这个目录。

**大致步骤**

- 在 Ubuntu 上安装 NFS 服务：

  ```
  sudo apt update
  sudo apt install nfs-kernel-server
  ```

- 创建并配置共享目录（例如 `/nfsroot`）：

  ```
  sudo mkdir nfsroot
  ```

  ```
  我创建的目录  /home/hdj/nfsroot  ，创建后给权限chmod 775 -R nfsroot
  ```

- 编辑 `/etc/exports` 文件，添加如下内容（我的开发板 IP 为 192.168.0.99）

  ```
  /home/hdj/nfsroot 192.168.0.99(rw,sync,no_root_squash,no_subtree_check)
  ```

- 重新导出配置并重启 NFS 服务：

  ```
  sudo exportfs -ra
  sudo systemctl restart nfs-kernel-server
  ```

- 查看nfs状态

```
sudo systemctl status nfs-kernel-server
```

![image-20250720015346696](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250720015346696.png)

- 将zImage 以及  imx6ull-alientek-emmc.dtb  文件放在nfsroot目录  

使用 nfs 命令来将 zImage 下载到开发板 DRAM 的 0X80800000 地址处， imx6ull-alientek-emmc.dtb下载到83000000处

下载zImage 

```
nfs 80800000 192.168.0.38:/home/hdj/nfsroot/zImage
```

下载dtb

```
nfs 83000000 192.168.0.38:/home/hdj/nfsroot/imx6ull-alientek-emmc.dtb
```

启动内核

```
bootz 80800000 - 83000000
```



![image-20250720022412627](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250720022412627.png)

## 挂载根文件系统

 **U-Boot** 下用于 NFS 网络启动的 bootargs 设置命令 ，这会在启动内核的时，自动运行该命令来挂载根文件系统

```
setenv bootargs console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.0.38:/home/hdj/nfsroot/rootfs,tcp ip=192.168.0.99:192.168.0.38:192.168.0.1:255.255.255.0::eth0:off

saveenv
```

### 1. setenv bootargs ...

- **作用**：设置 U-Boot 环境变量 `bootargs`，其内容会传递给 Linux 内核作为启动参数（cmdline）。

### 2. console=ttymxc0,115200

- **console=ttymxc0**：指定内核启动日志和串口终端使用的串口设备为 `ttymxc0`（i.MX6ULL 芯片的第1个串口，一般是 UART1）。
- **115200**：串口波特率为 115200bps。

### 3. root=/dev/nfs

- 告诉内核，**根文件系统（rootfs）挂载方式为 NFS**，而不是本地存储设备（如 eMMC/SD/flash）。
- `/dev/nfs` 是 Linux 内核约定的伪设备名，表示通过 NFS 挂载根文件系统。

### 4. nfsroot=192.168.0.38:/home/hdj/nfsroot/rootfs,tcp

- **nfsroot=服务器IP:目录路径,参数**
- `192.168.0.38`：NFS 服务器的 IP 地址
- `/home/hdj/nfsroot/rootfs`：NFS 服务器上要导出的根文件系统目录
- `tcp`：指定 NFS 传输协议使用 TCP（而不是 UDP）

### 5. ip=192.168.0.99:192.168.0.38:192.168.0.1:255.255.255.0::eth0:off

**格式为：**
 `ip=<client-ip>:<server-ip>:<gateway-ip>:<netmask>:<hostname>:<device>:<autoconf>`

- `192.168.0.99`：本机（开发板）的 IP 地址
- `192.168.0.38`：NFS 服务器的 IP 地址
- `192.168.0.1`：网关 IP 地址
- `255.255.255.0`：子网掩码
- `（空）`：主机名（hostname），这里省略不用
- `eth0`：使用的网络设备（通常开发板第1个以太网口）
- `off`：IP 地址不会自动获取（DHCP 关闭），完全用命令里的参数

### 总结

**该命令的作用是：**

- 设置开发板通过串口 ttymxc0 进行内核日志输出和交互
- 内核启动时，根文件系统不在本地，而是从 192.168.0.38 这台 PC 的 `/home/hdj/nfsroot/rootfs` 路径，通过 NFS（TCP协议）远程挂载
- 指定开发板的IP、网关、子网等全部参数，不需要DHCP

在执行上述的三条命令即可启动内核并自动挂载根文件系统

```
nfs 80800000 192.168.0.38:/home/hdj/nfsroot/zImage
nfs 83000000 192.168.0.38:/home/hdj/nfsroot/imx6ull-alientek-emmc.dtb
bootz 80800000 - 83000000
```

![image-20250720025823332](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250720025823332.png)

既然可以使用环境变量来自动挂载文件系统，那么应该也可以使用环境变量来运行这三条指令，我能想到。别人早就想到了

U-Boot中提供了一个bootcmd命令，在 U-Boot 启动时会自动执行的环境变量。U-Boot 启动后会自动 `run bootcmd`。

![image-20250720032806466](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250720032806466.png)

```
bootcmd=run findfdt;mmc dev ${mmcdev};mmc dev ${mmcdev}; if mmc rescan; then if run loadbootscript; then run bootscript; else if run loadimage; then run mmcboot; else run netboot; fi; fi; else run netboot; fi
```

### 分段解释：

1. **run findfdt**
   - 运行一个名为 `findfdt` 的环境变量（通常是自动判断和设置 `fdtfile` 设备树变量，适配不同硬件）。
2. **mmc dev ${mmcdev}; mmc dev ${mmcdev};**
   - 选择并切换到 `${mmcdev}` 指定的 mmc 设备（比如 emmc 或 sd 卡）。这里连写两遍是有的 U-Boot 平台这样更保险。
3. **if mmc rescan; then ... else ... fi**
   - 判断 mmc 设备是否可以被正确扫描（即卡/芯片插好可用）。
4. **if run loadbootscript; then run bootscript; else ... fi**
   - 尝试运行名为 `loadbootscript` 的变量（比如从 FAT 分区加载 bootscript 文件到内存）。如果加载成功，执行 `bootscript`（通常是板级自定义的启动脚本）。
5. **else if run loadimage; then run mmcboot; else run netboot; fi; fi**
   - 如果没有 bootscript，就尝试用 `loadimage`（通常指加载 zImage/uImage 内核），如果加载成功，执行 `mmcboot`（通常是启动内核+dtb+rootfs），否则就执行 `netboot`（通常是走 TFTP/NFS 网络启动）。
6. **else run netboot; fi**
   - 如果 mmc rescan 失败，直接走网络启动。

### **总结一句话：**

> **优先从本地 mmc 启动，先找 bootscript，其次找内核镜像；都没有就走网络启动。**



设置bootcmd 环境变量，让启动时自动从网络启动

```
setenv bootcmd 'nfs 80800000 192.168.0.38:/home/hdj/nfsroot/zImage; nfs 83000000 192.168.0.38:/home/hdj/nfsroot/imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000'

saveenv
```



![image-20250720033414629](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250720033414629.png)

完全断电，再开机，uboot启动后，应该会自动将内核，设备树，以及根文件系统挂载上



至此驱动开发的环境就弄好了，可以非常方便的更新内核，设备树，文件系统，这就是uboot的优势，我觉得uboot的演变也是为了满足开发需求，一开始应该是一个基础的跳转，发现开发时要频繁的下载，慢慢的演变成现在的uboot

