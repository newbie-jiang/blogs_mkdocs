# zlib 使用

https://zlib.net/

- **zlib**：历史最悠久、应用最广泛的通用压缩库（基于 DEFLATE 算法）。
  - **优点**：有很多移植经验、兼容性好，成熟稳定。
  - **缺点**：标准 zlib 代码体积较大，在资源极其有限的 MCU 上可能需要做裁剪。

## 编译

下载下来可以用camke编译测试

```shell
cd zlib-1.3.1
mkdir build && cd build
cmake ..
make
./example
```

```SHELL
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ ls
CMakeCache.txt  CMakeFiles  cmake_install.cmake  CTestTestfile.cmake  example  example64  foo.gz  libz.a  libz.so  libz.so.1  libz.so.1.3.1  Makefile  minigzip  minigzip64  zconf.h  zlib.pc
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ tree -L 1
.
├── CMakeCache.txt
├── CMakeFiles
├── cmake_install.cmake
├── CTestTestfile.cmake
├── example
├── example64
├── foo.gz
├── libz.a
├── libz.so -> libz.so.1
├── libz.so.1 -> libz.so.1.3.1
├── libz.so.1.3.1
├── Makefile
├── minigzip
├── minigzip64
├── zconf.h
└── zlib.pc

1 directory, 15 files
```

## **官方自带测试程序**

你的 `build` 目录下有以下可执行文件：

- `example`（zlib功能自测Demo）
- `minigzip`（gzip兼容性测试Demo）
- `example64` 和 `minigzip64`（64位文件支持测试）

------

### **（1）运行 zlib 官方例程**

**运行 example：**

```
./example
```

- 如果一切正常，输出会包含 `zlib version x.x.x = 0xxxx, compile flags = ...`
- 并显示一系列 `test passed` 字样。

```
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ ./example
zlib version 1.3.1 = 0x1310, compile flags = 0xa9
uncompress(): hello, hello!
gzread(): hello, hello!
gzgets() after gzseek:  hello!
inflate(): hello, hello!
large_inflate(): OK
after inflateSync(): hello, hello!
inflate with dictionary: hello, hello!
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ 
```



**运行 example64：**

```
./example64
```

- 输出应该与上面类似（测试64位文件支持）。

```
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ ./example64
zlib version 1.3.1 = 0x1310, compile flags = 0xa9
uncompress(): hello, hello!
gzread(): hello, hello!
gzgets() after gzseek:  hello!
inflate(): hello, hello!
large_inflate(): OK
after inflateSync(): hello, hello!
inflate with dictionary: hello, hello!
```

------

### **（2）运行 minigzip 测试压缩/解压**

**压缩一个文件：**

- 压缩后会删除源文件

```
echo "hello zlib" > test.txt
./minigzip test.txt
```

- 得到 `test.txt.gz`

![image-20250806173043135](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250806173043135.png)

**解压：**

```
./minigzip -d test.txt.gz
cat test.txt
```

- 会得到 `test.txt`（内容和原来一样）

```
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ ./minigzip -d test.txt.gz
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ ls
CMakeCache.txt  CMakeFiles  cmake_install.cmake  CTestTestfile.cmake  example  example64  foo.gz  libz.a  libz.so  libz.so.1  libz.so.1.3.1  Makefile  minigzip  minigzip64  test.txt  zconf.h  zlib.pc
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/zlib-1.3.1/build$ cat test.txt
hello zlib
```



 zlib 默认只需要运行 `example` 和 `minigzip` 就可以验证基本功能。



## 核心文件介绍

直接看camke文件中那些文件参与了编译

```
set(ZLIB_SRCS
    adler32.c
    compress.c
    crc32.c
    deflate.c
    gzclose.c
    gzlib.c
    gzread.c
    gzwrite.c
    inflate.c
    infback.c
    inftrees.c
    inffast.c
    trees.c
    uncompr.c
    zutil.c
)
```



### 1. **adler32.c**

- **功能**：实现 Adler-32 校验算法（一个快速的流式校验码算法）
- **用途**：为压缩流和数据块生成校验值，检测数据完整性

------

### 2. **compress.c**

- **功能**：提供 zlib 高层接口的压缩函数（如 `compress()`）
- **用途**：封装底层 deflate 算法，为用户提供简单的压缩 API

------

### 3. **crc32.c**

- **功能**：实现 CRC32 校验算法
- **用途**：生成更强的32位数据校验码，常用于 gzip、zip、png 等格式的数据完整性校验

------

### 4. **deflate.c**

- **功能**：核心压缩算法（deflate）
- **用途**：实现 LZ77 + Huffman 编码压缩，zlib 的“压缩心脏”，大部分数据压缩逻辑都在这里

------

### 5. **gzclose.c**

- **功能**：`.gz` 文件高层接口的关闭操作
- **用途**：实现 `gzclose()`，用于关闭压缩文件流，释放相关资源

------

### 6. **gzlib.c**

- **功能**：`.gz` 文件读写的主库代码
- **用途**：封装底层压缩/解压，对应 `gzopen()`、`gzread()`、`gzwrite()` 等 API，实现 `.gz` 文件的操作

------

### 7. **gzread.c**

- **功能**：`.gz` 文件的读取实现
- **用途**：处理 `.gz` 文件流的解压和数据读取，解码压缩数据

------

### 8. **gzwrite.c**

- **功能**：`.gz` 文件的写入实现
- **用途**：处理 `.gz` 文件流的压缩和数据写入，编码并保存数据

------

### 9. **inflate.c**

- **功能**：核心解压缩算法（inflate）
- **用途**：实现 deflate 格式的解码与解压，是 zlib 的“解压心脏”，对应流式解压操作

------

### 10. **infback.c**

- **功能**：特殊的“向后”解压算法（backwards inflate）
- **用途**：为需要自定义输入输出（如嵌入式流式解压）提供更灵活的 inflate 接口（`inflateBack`）

------

### 11. **inftrees.c**

- **功能**：Huffman 树的构建和处理
- **用途**：支持 deflate/inflate 的 Huffman 编码/解码树管理（压缩率优化和解压效率提升）

------

### 12. **inffast.c**

- **功能**：加速版的 inflate 解码实现
- **用途**：为 inflate 操作提供快速路径，提高解压速度

------

### 13. **trees.c**

- **功能**：Huffman 树的生成、管理和优化
- **用途**：支持压缩算法中的动态/静态树构建，决定数据如何编码以获得最优压缩率

------

### 14. **uncompr.c**

- **功能**：高层“解压”接口（如 `uncompress()`）
- **用途**：为用户提供简单的解压缩函数，直接调用底层 inflate 算法

------

### 15. **zutil.c**

- **功能**：zlib 内部工具函数（通用支持）
- **用途**：包含内存管理、错误处理、字节序转换等 zlib 公用辅助函数

------

## 核心文件总结

- **deflate.c/inflate.c**：压缩与解压核心
- **crc32.c/adler32.c**：数据校验核心
- **gzlib.c/gzread.c/gzwrite.c/gzclose.c**：`.gz` 文件操作接口
- **compress.c/uncompr.c**：简单易用的高层（单次）压缩解压API
- **inftrees.c/trees.c/inffast.c/infback.c**：Huffman树算法和快速路径、灵活的流式支持
- **zutil.c**：内部通用工具



## 官方测试文件

![image-20250806174231415](https://newbie-typora.oss-cn-shenzhen.aliyuncs.com/TyporaJPG/image-20250806174231415.png)

1. `infcover.c` —— **inflate 覆盖率测试程序**

### 作用：

- 专门为**测试 zlib 的解压（inflate）相关代码的覆盖率**而写。
- 用于 zlib 官方 CI 或开发人员，确保各种代码路径、边界、异常和 corner case 都被测试到。

### 主要内容与结构：

- **自定义内存分配跟踪**（mem_setup/mem_limit/mem_used/mem_high/mem_done）：
  - 检测内存分配/释放的正确性，查内存泄漏、非法释放等。
- **一系列特殊输入构造和解压用例**（如 bad header、bad method、需要字典、内存限制等）。
- **多种 inflate 初始化参数**，覆盖所有 inflate* 系列函数及不同窗口大小、header、字典相关、buffer 行为等。
- **直接调用 zlib 内部函数（如 inflate_table）**，甚至包括部分未导出的 API。
- **主要用于自动化测试和开发者调试，不建议普通用户或嵌入式直接移植。**

### 典型场景：

- 想改 zlib 的源码，或者做“全路径单元测试”，这个程序可以帮助你发现解压相关的极端/错误处理是否被覆盖。

------

2. `minigzip.c` —— **简化版 gzip 压缩/解压工具**

作用：

- **最小实现的 gzip 命令行工具**，基于 zlib。
- 既能压缩（生成 .gz 文件），也能解压 .gz 文件。
- 主要用来演示 zlib 的实际文件流压缩/解压接口（gz* 系列函数）用法。
- 不同于官方 gzip，minigzip 是个教学/测试工具，不含复杂参数和平台兼容性，仅为示例用途。

主要内容与结构：

- **压缩/解压核心流程**：
  - `gz_compress()`：将文件/流压缩成 .gz。
  - `gz_uncompress()`：将 .gz 文件解压成普通文件/流。
- **主函数支持 gzip/gunzip/zcat/minigzip 多种行为**：
  - 支持常用参数（如 -c、-d、-1...-9 压缩级别）。
- **支持 MMAP 优化**（可选，用于一次 mmap 读取整个文件，适合大文件）。
- **文件和管道模式兼容**：可用于普通文件和标准输入/输出流压缩。
- **移植性好，代码风格接近 POSIX。**

典型场景：

- 想用 zlib 作为后端写自己的压缩/解压工具，可以照着 minigzip 学习。
- 想了解 gz* API 的实际用法。

------

3. `example.c` —— **zlib API 综合功能演示样例**

作用：

- **zlib 官方最全功能演示代码**，包含内存压缩/解压、文件压缩/解压、流模式、带字典、flush/sync、各种 buffer 策略等全部主流 API 用法。
- 适合作为“zlib 编程入门教材”或最小可运行样例。

主要内容与结构：

- **compress()/uncompress()**：一步到位的内存压缩/解压。
- **deflate/inflate 流模式**：手动管理输入/输出 buffer，控制 flush/sync 行为，兼容高级用法。
- **.gz 文件读写**：用 gzopen/gzread/gzwrite/gzseek/gzgetc/gzputs/gzprintf/gzgets 等 API 操作 gzip 文件。
- **带字典压缩/解压**：展示 deflateSetDictionary/inflateSetDictionary 的用法。
- **main() 按顺序测试上述所有功能点**，并输出结果。
- **代码注释清晰，非常适合嵌入式或新手移植参考。**

典型场景：

- 嵌入式开发需要内存压缩/解压功能，可以摘取相应部分直接复用。
- 学习 zlib API 之间的关系、调用流程，调试 zlib 库。
- 验证自己编译的 zlib 库基本功能是否正常。

------

官方测试文件总结与适用建议

- **infcover.c**：面向 zlib 内部开发/测试，自动化全覆盖解压代码路径，不用于实际数据压缩任务。
- **minigzip.c**：功能简明的 gzip 命令行工具 demo，适合学习文件级流压缩/解压和 gz* API。
- **example.c**：zlib 各种典型用法的完整展示，最适合做入门样例、嵌入式移植参考、功能验证。

