**miniz**：zlib 的极简实现，单文件、适合 MCU。

- **优点**：只需一个源文件即可集成，内存占用低。

https://github.com/richgel999/miniz

## 文件结构

文件结构看着非常简单，提供了6个测试文件

```
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/miniz-3.0.2$ tree -L 2
.
├── ChangeLog.md
├── examples
│   ├── example1.c
│   ├── example2.c
│   ├── example3.c
│   ├── example4.c
│   ├── example5.c
│   └── example6.c
├── miniz.c
├── miniz.h
└── readme.md

1 directory, 10 files
```

文件较少就不写cmake文件了，直接测试, 我先改了一下文件结构，如下

```
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/miniz-3.0.2$ tree -L 2
.
├── ChangeLog.md
├── examples_src
│   ├── example1.c
│   ├── example2.c
│   ├── example3.c
│   ├── example4.c
│   ├── example5.c
│   └── example6.c
├── readme.md
└── src
    ├── miniz.c
    └── miniz.h
```

在miniz-3.0.2目录下直接编译

```
gcc examples_src/example1.c src/miniz.c -I./src -o example1
```



```
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/miniz-3.0.2$ gcc examples_src/example1.c src/miniz.c -I./src -o example1
src/miniz.c:3185:9: note: ‘#pragma message: Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.’
 3185 | #pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
      |         ^~~~~~~
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/miniz-3.0.2$ ls
ChangeLog.md  example1  examples_src  miniz_test.c  readme.md  src
hdj@hdj-virtual-machine:~/stm32-cmake-for-vscode/lib/miniz-3.0.2$ ./example1
miniz.c version: 11.0.2
Compressed from 490 to 81 bytes
Decompressed from 81 to 490 bytes
Success.

```



## 六个测试文件解析

### **example1.c**

- **演示内容：**
   最简单的字符串内存压缩与解压。
   **主要用 miniz 的 `compress()` 和 `uncompress()`（zlib 兼容接口）**
- **测试重点：**
  - 字符串压缩后长度/解压后数据正确性
  - 支持简单模糊测试（故意篡改压缩数据）
- **适合**：快速验证 miniz/zlib API 在 MCU、嵌入式环境能否跑通

------

### **example2.c**

- **演示内容：**
   ZIP 文件归档（压缩/解压 ZIP 文件）API 用法
- **测试重点：**
  - 批量将内存字符串作为文件加入 ZIP 包
  - 打开 ZIP 文件遍历内容，按文件名解压验证数据
  - 支持目录、文件注释
- **适合**：测试 miniz 的 ZIP 归档功能、ZIP 文件互操作兼容性

------

### **example3.c**

- **演示内容：**
   使用 `deflate()`/`inflate()` 实现文件压缩/解压
- **测试重点：**
  - 命令行工具模式：`c` 压缩文件、`d` 解压文件
  - 支持调整压缩等级
- **适合**：模拟实际文件的压缩/解压，验证流式接口与大数据兼容性

------

### **example4.c**

- **演示内容：**
   使用底层 `tinfl_decompress_mem_to_callback()` 接口，将内存中的 zlib 压缩流解压到文件
- **测试重点：**
  - 读入整个压缩流到内存
  - 解压到回调输出（本例输出到文件）
- **适合**：测试底层 tinfl 解压性能与自定义数据流解包能力

------

### **example5.c**

- **演示内容：**
   演示 miniz 最底层的 tdefl_compress()（无动态分配，无 zlib API/无 malloc/无 stdio/无 archive API）和 tinfl_inflate()
- **测试重点：**
  - 超低依赖、适合最极限嵌入式环境
  - 文件压缩/解压流处理，零动态分配
  - 用法非常灵活、效率最高
- **适合**：资源极度有限、需要极小移植体积的场景或做库最底层测试

------

### **example6.c**

- **演示内容：**
   演示 miniz PNG 写入器 API，生成曼德勃罗特分形图片并保存为 PNG 文件
- **测试重点：**
  - 图像生成（无外部依赖），色彩转换
  - 调用 miniz 的 PNG 内存写接口生成高分辨率 PNG
- **适合**：验证 miniz 的图片编码能力和内存/输出流接口（需要链接 libm）

------

## **总结表**

| 示例       | 功能/测试点                       | 用途/场景                         |
| ---------- | --------------------------------- | --------------------------------- |
| example1.c | compress/uncompress 内存压缩      | 基本压缩解压API测试、快速验证     |
| example2.c | ZIP归档API，批量加文件、解包      | 文件归档/解包、兼容性验证         |
| example3.c | deflate/inflate 流式文件压缩/解压 | 文件压缩解压命令行模拟、流API测试 |
| example4.c | tinfl底层解压，内存流到文件输出   | 底层流解压/自定义输出回调         |
| example5.c | tdefl/tinfl底层无依赖压缩/解压    | 极简嵌入式移植、零动态分配场景    |
| example6.c | PNG写入器API+分形图生成           | 图像编码能力、复杂数据流测试      |

